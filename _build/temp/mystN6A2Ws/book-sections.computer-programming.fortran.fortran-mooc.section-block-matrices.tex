\begin{verbatim}
- - -
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
 - - -
\end{verbatim}

\subparagraph{Section: Block Matrices}

Adapted from: \href{https://github.com/gjbex/Fortran-MOOC/tree/master/source\_code/block\_matrices}{https://github.com/gjbex/Fortran-MOOC/tree/master/source\_code/block\_matrices}

\subparagraph{This program demonstrates using the Forall construct operate on a block matrix in Fortran.}

The Fortran program \texttt{block\_matrix} is designed to generate a block diagonal matrix, where each block along the diagonal is filled with ones, and the rest of the matrix is filled with zeros. The size of the matrix and the blocks within it can be specified by command-line arguments or default to a predefined size if no arguments are provided. Here's an in-depth explanation of the components and functionalities of the program:

\subparagraph{Key Components of the Program}

\begin{enumerate}
\item \textbf{Variable Declarations}

\begin{itemize}
\item \texttt{matrix\_size}: The size of the square matrix.
\item \texttt{block\_size}: The size of the blocks that will be filled with ones along the diagonal.
\item \texttt{data}: A dynamically allocated 2D integer array that holds the matrix data.
\end{itemize}


\item \textbf{Flow of Execution}

\begin{itemize}
\item The program starts by calling \texttt{get\_parameters} to set the \texttt{matrix\_size} and \texttt{block\_size}, either from command-line arguments or default values.
\item It then creates the block matrix using the \texttt{create\_block\_matrix} function.
\item The matrix is printed using \texttt{print\_matrix}.
\item Finally, the allocated matrix is deallocated.
\end{itemize}
\end{enumerate}

\subparagraph{Detailed Explanation of Subroutines and Functions}

\subparagraph{\texttt{get\_parameters(matrix\_size, block\_size)}}

\begin{itemize}
\item \textbf{Purpose}: To fetch and validate the size of the matrix and blocks from command-line arguments.
\item \textbf{Input Handling}: If two command-line arguments are provided, they are read and assigned to \texttt{matrix\_size} and \texttt{block\_size}. If the reading fails (detected by \texttt{iostat}), an error message is displayed.
\item \textbf{Defaults}: If not exactly two command-line arguments are given, defaults to a matrix size of 9 and a block size of 3.
\end{itemize}

\subparagraph{\texttt{create\_block\_matrix(matrix\_size, block\_size)}}

\begin{itemize}
\item \textbf{Purpose}: To generate a block diagonal matrix based on specified sizes.
\item \textbf{Process}:

\begin{itemize}
\item The matrix \texttt{B} is allocated with dimensions \texttt{matrix\_size x matrix\_size}.
\item A nested \texttt{forall} construct is used to fill the diagonal blocks with ones. The construct iterates over starting points of blocks (variable \texttt{i}) and then fills a \texttt{block\_size x block\_size} block from each starting point \texttt{(i, i)}.
\item The conditional within the \texttt{forall} ensures that the filling does not exceed the matrix dimensions, avoiding out-of-bound errors.
\end{itemize}


\item \textbf{Error Handling}: If allocation fails, an error message is printed and the program is stopped.
\end{itemize}

\subparagraph{\texttt{print\_matrix(A)}}

\begin{itemize}
\item \textbf{Purpose}: To print the matrix to the standard output.
\item \textbf{Details}: Iterates over each row of the matrix \texttt{A} and prints the elements formatted as integers.
\end{itemize}

\subparagraph{Special Features and Techniques Used}

\begin{itemize}
\item \textbf{Command Argument Processing}: Demonstrates basic usage of \texttt{get\_command\_argument} for customizable program behavior.
\item \textbf{Error Handling in Allocation}: Uses \texttt{stat} and \texttt{error\_unit} to manage and respond to allocation failures.
\item \textbf{Matrix Construction with \texttt{forall}}: Efficiently constructs block matrices using a \texttt{forall} statement, a parallel loop construct suited for operations on arrays.
\end{itemize}

\subparagraph{Sample Output Explanation}

Given a \texttt{matrix\_size} of 9 and a \texttt{block\_size} of 3, the matrix \texttt{B} would look like this:

\begin{verbatim}
111000000
111000000
111000000
000111000
000111000
000111000
000000111
000000111
000000111
\end{verbatim}

Each \texttt{1} represents a filled element within a \texttt{3x3} block along the diagonal in a \texttt{9x9} matrix.

\subparagraph{Usage Scenario}

This program could be useful in numerical simulations or mathematical modeling where block diagonal matrices are required, such as in block iterative methods for solving large sparse systems of equations.

\subparagraph{Program Code}

In file \textit{section\_block\_matrices.f90}

\begin{verbatim}
program block_matrix
    implicit none
    integer :: matrix_size, block_size
    integer, dimension(:, :), allocatable :: data

    call get_parameters(matrix_size, block_size)
    data = create_block_matrix(matrix_size, block_size) 
    call print_matrix(data)
    deallocate (data)

contains

    subroutine get_parameters(matrix_size, block_size)
        use, intrinsic :: iso_fortran_env, only : error_unit
        implicit none
        integer, intent(out) :: matrix_size, block_size
        character(len=1024) :: buffer, msg
        integer :: status

        if (command_argument_count() == 2) then
            call get_command_argument(1, buffer)
            read (buffer, fmt=*, iostat=status, iomsg=msg) matrix_size
            if (status /= 0) then
                write (unit=error_unit, fmt='(2A)') 'error: ', msg
            end if
            call get_command_argument(2, buffer)
            read (buffer, fmt=*, iostat=status, iomsg=msg) block_size
            if (status /= 0) then
                write (unit=error_unit, fmt='(2A)') 'error: ', msg
            end if
        else
            matrix_size = 9
            block_size = 3
        end if
    end subroutine get_parameters

    function create_block_matrix(matrix_size, block_size) result(B)
        use, intrinsic :: iso_fortran_env, only : error_unit
        implicit none
        integer, value :: matrix_size, block_size
        integer, dimension(:, :), allocatable :: B
        integer :: i, j, k, status

        allocate (B(matrix_size, matrix_size), stat=status)
        if (status /= 0) then
            write (unit=error_unit, fmt='(2A)') &
                'error: can not allocate matrix'
            stop 2
        end if
        B = 0
        forall (i = 1:size(B, 1):block_size, &
                j = 0:block_size - 1, &
                k = 0:block_size - 1, &
                i + j <= size(B, 1) .and. i + k <= size(B, 2))
            B(i + j, i + k) = 1
        end forall
    end function create_block_matrix

    subroutine print_matrix(A)
        implicit none
        integer, dimension(:, :), intent(in) :: A
        integer :: i

        do i = 1, size(A, 1)
            print '(*(I3))', A(i, :)
        end do
    end subroutine print_matrix

end program block_matrix
\end{verbatim}

The above program is compiled and run using Fortran Package Manager (fpm):

\subparagraph{Build the Program using FPM (Fortran Package Manager)}

\begin{verbatim}
import os
root_dir = ""
root_dir = os.getcwd()
\end{verbatim}

Since the code makes use of the LAPACK library, the following FPM configuration file (fpm.toml) was used:

\begin{verbatim}
name = "Section_Block_Matrices"

[build]
auto -executables = true
auto -tests = true
auto -examples = true
module -naming = false

[install]
library = false

[fortran]
implicit -typing = false
implicit -external = false
source -form = "free"

[[executable]]
name="Section_Block_Matrices"
source -dir="app"
main="section_block_matrices.f90"
\end{verbatim}

\begin{verbatim}
code_dir = root_dir + "/" + "Fortran_Code/Section_Block_Matrices/"
\end{verbatim}

\begin{verbatim}
os.chdir(code_dir)
\end{verbatim}

\begin{verbatim}
build_status = os.system("fpm build 2>/dev/null")
\end{verbatim}

\subparagraph{Run the Program using FPM (Fortran Package Manager)}

\begin{verbatim}
exec_status = \
    os.system("fpm run 2>/dev/null")
\end{verbatim}

\begin{verbatim}
1  1  1  0  0  0  0  0  0
  1  1  1  0  0  0  0  0  0
  1  1  1  0  0  0  0  0  0
  0  0  0  1  1  1  0  0  0
  0  0  0  1  1  1  0  0  0
  0  0  0  1  1  1  0  0  0
  0  0  0  0  0  0  1  1  1
  0  0  0  0  0  0  1  1  1
  0  0  0  0  0  0  1  1  1
\end{verbatim}