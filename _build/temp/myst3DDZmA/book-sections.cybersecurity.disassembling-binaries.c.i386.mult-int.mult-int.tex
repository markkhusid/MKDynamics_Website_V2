\subparagraph{Multiplying Integers: i386}

\includegraphics[width=0.7\linewidth]{files/mult_int_C_i386_spla-13fbd88b020fdf331084d500fd976c02.png}

\subparagraph{Introduction}

In this section we will examine the disassembly of a simple C program that multiplies two integers. The program is compiled for the i386 architecture, which is a 32-bit architecture commonly used in older computers and embedded systems. The disassembly will help us understand how the C code translates into assembly instructions, and how these instructions are executed by the CPU.

\subparagraph{The C Program}

\begin{verbatim}
#include <stdio.h>

int main(int argc, char * argv[])
{
	int a, b, c;
	
	a = 2;
	b = 3;

	c = a * b;
}
\end{verbatim}

\subparagraph{Compilation of the C Program to Produce Assembly Code and Object Code}

The C program is compiled using the GCC compiler with the \texttt{-m32} flag to specify the i386 architecture. The \texttt{-masm=intel} flag creates assembly code in the Intel format. The \texttt{-S} flag generates assembly code, the \texttt{-fverbose-asm} flag includes C source code in the assembly code, and the \texttt{-c} flag compiles the assembly code into an object file.

\begin{verbatim}
gcc - -sysroot=/ -m32 -masm=intel -S -fverbose -asm mult_int.c -o mult_int.s
gcc - -sysroot=/ -m32 -c mult_int.s -o mult_int.o
\end{verbatim}

\subparagraph{Viewing the Assembly Code}

The assembly code is in Intel syntax, which is commonly used for x86 assembly language.

\begin{verbatim}
.file	"mult_int.c"
	.intel_syntax noprefix
# GNU C17 (conda -forge gcc 14.2.0 -2) version 14.2.0 (x86_64 -conda -linux -gnu)
#	compiled by GNU C version 14.2.0, GMP version 6.2.1, MPFR version 4.1.0, MPC version 1.2.1, isl version isl -0.24 -GMP

# GGC heuristics: - -param ggc -min -expand=100 - -param ggc -min -heapsize=131072
# options passed: -m32 -masm=intel -mtune=generic -march=x86 -64
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	push	ebp	#
	.cfi_def_cfa_offset 8
	.cfi_offset 5, -8
	mov	ebp, esp	#,
	.cfi_def_cfa_register 5
	sub	esp, 16	#,
	call	__x86.get_pc_thunk.ax	#
	add	eax, OFFSET FLAT:_GLOBAL_OFFSET_TABLE_	# tmp98,
# mult_int.c:7: 	a = 2;
	mov	DWORD PTR -4[ebp], 2	# a,
# mult_int.c:8: 	b = 3;
	mov	DWORD PTR -8[ebp], 3	# b,
# mult_int.c:10: 	c = a * b;
	mov	eax, DWORD PTR -4[ebp]	# tmp102, a
	imul	eax, DWORD PTR -8[ebp]	# c_3, b
	mov	DWORD PTR -12[ebp], eax	# c, c_3
	mov	eax, 0	# _4,
# mult_int.c:11: }
	leave	
	.cfi_restore 5
	.cfi_def_cfa 4, 4
	ret	
	.cfi_endproc
.LFE0:
	.size	main, . -main
	.section	.text.__x86.get_pc_thunk.ax,"axG",@progbits,__x86.get_pc_thunk.ax,comdat
	.globl	__x86.get_pc_thunk.ax
	.hidden	__x86.get_pc_thunk.ax
	.type	__x86.get_pc_thunk.ax, @function
__x86.get_pc_thunk.ax:
.LFB1:
	.cfi_startproc
	mov	eax, DWORD PTR [esp]	#,
	ret
	.cfi_endproc
.LFE1:
	.ident	"GCC: (conda -forge gcc 14.2.0 -2) 14.2.0"
	.section	.note.GNU -stack,"",@progbits
\end{verbatim}

\subparagraph{Explanation of the Assembly Code}

The attached code is an assembly file (\texttt{mult\_int.s}) generated from a simple C program (\texttt{mult\_int.c}) that performs integer multiplication. It is written in Intel syntax and compiled for a 32-bit architecture (\texttt{-m32}) using GCC 14.2.0. Below is a detailed explanation of the code:


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Header Information}}

\begin{verbatim}
.file	"mult_int.c"
	.intel_syntax noprefix
\end{verbatim}

\begin{itemize}
\item \texttt{.file "mult\_int.c"}: Indicates that this assembly code was generated from the C source file \texttt{mult\_int.c}.
\item \texttt{.intel\_syntax noprefix}: Specifies that the assembly code uses Intel syntax (as opposed to AT\&T syntax).
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Global and Function Declarations}}

\begin{verbatim}
.text
	.globl	main
	.type	main, @function
\end{verbatim}

\begin{itemize}
\item \texttt{.text}: Marks the beginning of the code (text) section where executable instructions are stored.
\item \texttt{.globl main}: Declares the \texttt{main} function as global, making it accessible to the linker.
\item \texttt{.type main, @function}: Specifies that \texttt{main} is a function.
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Main Function}}

\begin{verbatim}
main:
.LFB0:
	.cfi_startproc
\end{verbatim}

\begin{itemize}
\item \texttt{main:}: The label for the \texttt{main} function.
\item \texttt{.LFB0:}: A local label used internally by the assembler for debugging purposes.
\item \texttt{.cfi\_startproc}: Marks the start of the Call Frame Information (CFI) for the function, used for stack unwinding during debugging.
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Prologue}}

\begin{verbatim}
push	ebp	#
	.cfi_def_cfa_offset 8
	.cfi_offset 5, -8
	mov	ebp, esp	#,
	.cfi_def_cfa_register 5
	sub	esp, 16	#,
\end{verbatim}

\begin{itemize}
\item \texttt{push ebp}: Saves the base pointer (\texttt{ebp}) of the previous stack frame onto the stack.
\item \texttt{mov ebp, esp}: Sets the current base pointer (\texttt{ebp}) to the value of the stack pointer (\texttt{esp}), establishing a new stack frame.
\item \texttt{sub esp, 16}: Allocates 16 bytes of space on the stack for local variables.
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Global Offset Table Setup}}

\begin{verbatim}
call	__x86.get_pc_thunk.ax	#
	add	eax, OFFSET FLAT:_GLOBAL_OFFSET_TABLE_	# tmp98,
\end{verbatim}

\begin{itemize}
\item \texttt{call \_\_x86.get\_pc\_thunk.ax}: Calls a helper function to get the program counter (PC) value.
\item \texttt{add eax, OFFSET FLAT:\_GLOBAL\_OFFSET\_TABLE\_}: Adjusts the PC value to point to the Global Offset Table (GOT), which is used for position-independent code.
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Variable Initialization}}

\begin{verbatim}
# mult_int.c:7: 	a = 2;
	mov	DWORD PTR -4[ebp], 2	# a,
# mult_int.c:8: 	b = 3;
	mov	DWORD PTR -8[ebp], 3	# b,
\end{verbatim}

\begin{itemize}
\item \texttt{mov DWORD PTR -4[ebp], 2}: Stores the value \texttt{2} in the memory location \texttt{-4[ebp]}, which corresponds to the variable \texttt{a}.
\item \texttt{mov DWORD PTR -8[ebp], 3}: Stores the value \texttt{3} in the memory location \texttt{-8[ebp]}, which corresponds to the variable \texttt{b}.
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Multiplication}}

\begin{verbatim}
# mult_int.c:10: 	c = a * b;
	mov	eax, DWORD PTR -4[ebp]	# tmp102, a
	imul	eax, DWORD PTR -8[ebp]	# c_3, b
	mov	DWORD PTR -12[ebp], eax	# c, c_3
\end{verbatim}

\begin{itemize}
\item \texttt{mov eax, DWORD PTR -4[ebp]}: Loads the value of \texttt{a} into the \texttt{eax} register.
\item \texttt{imul eax, DWORD PTR -8[ebp]}: Multiplies the value in \texttt{eax} (i.e., \texttt{a}) by the value of \texttt{b} (stored at \texttt{-8[ebp]}), storing the result in \texttt{eax}.
\item \texttt{mov DWORD PTR -12[ebp], eax}: Stores the result of the multiplication (\texttt{c}) in the memory location \texttt{-12[ebp]}.
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Return Value}}

\begin{verbatim}
mov	eax, 0	# _4,
\end{verbatim}

\begin{itemize}
\item \texttt{mov eax, 0}: Sets the return value of the \texttt{main} function to \texttt{0} (standard convention for successful execution).
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Epilogue}}

\begin{verbatim}
leave	
	.cfi_restore 5
	.cfi_def_cfa 4, 4
	ret	
	.cfi_endproc
\end{verbatim}

\begin{itemize}
\item \texttt{leave}: Restores the previous stack frame by setting \texttt{esp} to \texttt{ebp} and popping the old \texttt{ebp} value from the stack.
\item \texttt{ret}: Returns control to the caller.
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Helper Function: \texttt{\_\_x86.get\_pc\_thunk.ax}}}

\begin{verbatim}
.section	.text.__x86.get_pc_thunk.ax,"axG",@progbits,__x86.get_pc_thunk.ax,comdat
	.globl	__x86.get_pc_thunk.ax
	.hidden	__x86.get_pc_thunk.ax
	.type	__x86.get_pc_thunk.ax, @function
__x86.get_pc_thunk.ax:
.LFB1:
	.cfi_startproc
	mov	eax, DWORD PTR [esp]	#,
	ret
	.cfi_endproc
\end{verbatim}

\begin{itemize}
\item This function retrieves the program counter (PC) value and stores it in the \texttt{eax} register. It is used for position-independent code to calculate addresses relative to the GOT.
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Footer}}

\begin{verbatim}
.ident	"GCC: (conda -forge gcc 14.2.0 -2) 14.2.0"
	.section	.note.GNU -stack,"",@progbits
\end{verbatim}

\begin{itemize}
\item \texttt{.ident}: Contains metadata about the compiler version used.
\item \texttt{.section .note.GNU-stack}: Marks the stack as non-executable for security purposes.
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Summary}}

This assembly code implements a simple C program that multiplies two integers (\texttt{a = 2} and \texttt{b = 3}) and stores the result in a variable (\texttt{c}). The \texttt{main} function sets up the stack frame, performs the multiplication using the \texttt{imul} instruction, and returns \texttt{0} as the exit status. The helper function \texttt{\_\_x86.get\_pc\_thunk.ax} is used for position-independent code.

\subparagraph{Compilation to Produce Executable Code}

The object file is linked to create an executable file using the \texttt{-o} flag.

\begin{verbatim}
/usr/bin/gcc -m32 mult_int.o -o mult_int_C_i386
\end{verbatim}

\subparagraph{Disassembly of the Executable Code}

The executable file is disassembled using the \texttt{objdump} command with the \texttt{-d} flag to display the disassembly.

\begin{verbatim}
objdump -x -D -s -t -Mintel mult_int.o > objdump_of_dot_o.txt
objdump -x -D -s -t -Mintel mult_int_C_i386 > objdump_of_dot_exe.txt
\end{verbatim}

\subparagraph{Explanation of the Switches used in the \texttt{objdump} command:}

\begin{itemize}
\item \texttt{-x}: Displays all headers.
\item \texttt{-D}: Disassembles all sections.
\item \texttt{-s}: Displays the full contents of all sections.
\item \texttt{-t}: Displays the symbol table.
\item \texttt{-Mintel}: Specifies Intel syntax for disassembly.
\end{itemize}

\subparagraph{Viewing the Object File Disassembly}

\begin{verbatim}
mult_int.o:     file format elf32 -i386
mult_int.o
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .group        00000008  00000000  00000000  00000034  2**2
                  CONTENTS, READONLY, GROUP, LINK_ONCE_DISCARD
  1 .text         0000002f  00000000  00000000  0000003c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  2 .data         00000000  00000000  00000000  0000006b  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000000  00000000  00000000  0000006b  2**0
                  ALLOC
  4 .text.__x86.get_pc_thunk.ax 00000004  00000000  00000000  0000006b  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .comment      00000028  00000000  00000000  0000006f  2**0
                  CONTENTS, READONLY
  6 .note.GNU -stack 00000000  00000000  00000000  00000097  2**0
                  CONTENTS, READONLY
  7 .note.gnu.property 00000028  00000000  00000000  00000098  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .eh_frame     0000004c  00000000  00000000  000000c0  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 mult_int.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .text.__x86.get_pc_thunk.ax	00000000 .text.__x86.get_pc_thunk.ax
00000000 g     F .text	0000002f main
00000000 g     F .text.__x86.get_pc_thunk.ax	00000000 .hidden __x86.get_pc_thunk.ax
00000000         *UND*	00000000 _GLOBAL_OFFSET_TABLE_


Contents of section .group:
 0000 01000000 06000000                    ........        
Contents of section .text:
 0000 5589e583 ec10e8fc ffffff05 01000000  U...............
 0010 c745fc02 000000c7 45f80300 00008b45  .E......E......E
 0020 fc0faf45 f88945f4 b8000000 00c9c3    ...E..E........ 
Contents of section .text.__x86.get_pc_thunk.ax:
 0000 8b0424c3                             ..$.            
Contents of section .comment:
 0000 00474343 3a202863 6f6e6461 2d666f72  .GCC: (conda -for
 0010 67652067 63632031 342e322e 302d3229  ge gcc 14.2.0 -2)
 0020 2031342e 322e3000                     14.2.0.        
Contents of section .note.gnu.property:
 0000 04000000 18000000 05000000 474e5500  ............GNU.
 0010 020001c0 04000000 00000000 010001c0  ................
 0020 04000000 01000000                    ........        
Contents of section .eh_frame:
 0000 14000000 00000000 017a5200 017c0801  .........zR..|..
 0010 1b0c0404 88010000 1c000000 1c000000  ................
 0020 00000000 2f000000 00410e08 8502420d  ..../....A....B.
 0030 056bc50c 04040000 10000000 3c000000  .k..........<...
 0040 00000000 04000000 00000000           ............    

Disassembly of section .group:

00000000 <.group>:
   0:	01 00                	add    DWORD PTR [eax],eax
   2:	00 00                	add    BYTE PTR [eax],al
   4:	06                   	push   es
   5:	00 00                	add    BYTE PTR [eax],al
	...

Disassembly of section .text:

00000000 <main>:
   0:	55                   	push   ebp
   1:	89 e5                	mov    ebp,esp
   3:	83 ec 10             	sub    esp,0x10
   6:	e8 fc ff ff ff       	call   7 <main+0x7>
			7: R_386_PC32	__x86.get_pc_thunk.ax
   b:	05 01 00 00 00       	add    eax,0x1
			c: R_386_GOTPC	_GLOBAL_OFFSET_TABLE_
  10:	c7 45 fc 02 00 00 00 	mov    DWORD PTR [ebp -0x4],0x2
  17:	c7 45 f8 03 00 00 00 	mov    DWORD PTR [ebp -0x8],0x3
  1e:	8b 45 fc             	mov    eax,DWORD PTR [ebp -0x4]
  21:	0f af 45 f8          	imul   eax,DWORD PTR [ebp -0x8]
  25:	89 45 f4             	mov    DWORD PTR [ebp -0xc],eax
  28:	b8 00 00 00 00       	mov    eax,0x0
  2d:	c9                   	leave
  2e:	c3                   	ret

Disassembly of section .text.__x86.get_pc_thunk.ax:

00000000 <__x86.get_pc_thunk.ax>:
   0:	8b 04 24             	mov    eax,DWORD PTR [esp]
   3:	c3                   	ret

Disassembly of section .comment:

00000000 <.comment>:
   0:	00 47 43             	add    BYTE PTR [edi+0x43],al
   3:	43                   	inc    ebx
   4:	3a 20                	cmp    ah,BYTE PTR [eax]
   6:	28 63 6f             	sub    BYTE PTR [ebx+0x6f],ah
   9:	6e                   	outs   dx,BYTE PTR ds:[esi]
   a:	64 61                	fs popa
   c:	2d 66 6f 72 67       	sub    eax,0x67726f66
  11:	65 20 67 63          	and    BYTE PTR gs:[edi+0x63],ah
  15:	63 20                	arpl   WORD PTR [eax],sp
  17:	31 34 2e             	xor    DWORD PTR [esi+ebp*1],esi
  1a:	32 2e                	xor    ch,BYTE PTR [esi]
  1c:	30 2d 32 29 20 31    	xor    BYTE PTR ds:0x31202932,ch
  22:	34 2e                	xor    al,0x2e
  24:	32 2e                	xor    ch,BYTE PTR [esi]
  26:	30 00                	xor    BYTE PTR [eax],al

Disassembly of section .note.gnu.property:

00000000 <.note.gnu.property>:
   0:	04 00                	add    al,0x0
   2:	00 00                	add    BYTE PTR [eax],al
   4:	18 00                	sbb    BYTE PTR [eax],al
   6:	00 00                	add    BYTE PTR [eax],al
   8:	05 00 00 00 47       	add    eax,0x47000000
   d:	4e                   	dec    esi
   e:	55                   	push   ebp
   f:	00 02                	add    BYTE PTR [edx],al
  11:	00 01                	add    BYTE PTR [ecx],al
  13:	c0 04 00 00          	rol    BYTE PTR [eax+eax*1],0x0
  17:	00 00                	add    BYTE PTR [eax],al
  19:	00 00                	add    BYTE PTR [eax],al
  1b:	00 01                	add    BYTE PTR [ecx],al
  1d:	00 01                	add    BYTE PTR [ecx],al
  1f:	c0 04 00 00          	rol    BYTE PTR [eax+eax*1],0x0
  23:	00 01                	add    BYTE PTR [ecx],al
  25:	00 00                	add    BYTE PTR [eax],al
	...

Disassembly of section .eh_frame:

00000000 <.eh_frame>:
   0:	14 00                	adc    al,0x0
   2:	00 00                	add    BYTE PTR [eax],al
   4:	00 00                	add    BYTE PTR [eax],al
   6:	00 00                	add    BYTE PTR [eax],al
   8:	01 7a 52             	add    DWORD PTR [edx+0x52],edi
   b:	00 01                	add    BYTE PTR [ecx],al
   d:	7c 08                	jl     17 <.eh_frame+0x17>
   f:	01 1b                	add    DWORD PTR [ebx],ebx
  11:	0c 04                	or     al,0x4
  13:	04 88                	add    al,0x88
  15:	01 00                	add    DWORD PTR [eax],eax
  17:	00 1c 00             	add    BYTE PTR [eax+eax*1],bl
  1a:	00 00                	add    BYTE PTR [eax],al
  1c:	1c 00                	sbb    al,0x0
  1e:	00 00                	add    BYTE PTR [eax],al
  20:	00 00                	add    BYTE PTR [eax],al
			20: R_386_PC32	.text
  22:	00 00                	add    BYTE PTR [eax],al
  24:	2f                   	das
  25:	00 00                	add    BYTE PTR [eax],al
  27:	00 00                	add    BYTE PTR [eax],al
  29:	41                   	inc    ecx
  2a:	0e                   	push   cs
  2b:	08 85 02 42 0d 05    	or     BYTE PTR [ebp+0x50d4202],al
  31:	6b c5 0c             	imul   eax,ebp,0xc
  34:	04 04                	add    al,0x4
  36:	00 00                	add    BYTE PTR [eax],al
  38:	10 00                	adc    BYTE PTR [eax],al
  3a:	00 00                	add    BYTE PTR [eax],al
  3c:	3c 00                	cmp    al,0x0
  3e:	00 00                	add    BYTE PTR [eax],al
  40:	00 00                	add    BYTE PTR [eax],al
			40: R_386_PC32	.text.__x86.get_pc_thunk.ax
  42:	00 00                	add    BYTE PTR [eax],al
  44:	04 00                	add    al,0x0
  46:	00 00                	add    BYTE PTR [eax],al
  48:	00 00                	add    BYTE PTR [eax],al
	...
\end{verbatim}

\subparagraph{Explanation the Object File Disassembly}

The attached file is the output of the \texttt{objdump} command applied to an object file (\texttt{mult\_int.o}). It provides a detailed view of the binary structure, including sections, symbols, and disassembled machine code. Below is a detailed explanation of the key parts of the file:


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{File Metadata}}

\begin{verbatim}
mult_int.o:     file format elf32 -i386
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
\end{verbatim}

\begin{itemize}
\item \textbf{File format}: The object file is in the ELF (Executable and Linkable Format) for a 32-bit Intel architecture (\texttt{elf32-i386}).
\item \textbf{Architecture}: The code is compiled for the i386 architecture (32-bit x86).
\item \textbf{Flags}:

\begin{itemize}
\item \texttt{HAS\_RELOC}: The file contains relocation entries, which are used to adjust addresses during linking.
\item \texttt{HAS\_SYMS}: The file contains a symbol table.
\end{itemize}


\item \textbf{Start address}: The entry point of the object file is at address \texttt{0x00000000}.
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Sections}}

The object file is divided into sections, each serving a specific purpose. Below are the key sections:

\subparagraph{\textbf{1. \texttt{.group}}}

\begin{verbatim}
Idx Name          Size      VMA       LMA       File off  Algn
  0 .group        00000008  00000000  00000000  00000034  2**2
                  CONTENTS, READONLY, GROUP, LINK_ONCE_DISCARD
\end{verbatim}

\begin{itemize}
\item \textbf{Purpose}: Groups related sections for optimization and linking.
\item \textbf{Attributes}:

\begin{itemize}
\item \texttt{CONTENTS}: Contains data.
\item \texttt{READONLY}: Read-only section.
\item \texttt{GROUP}: Groups related sections.
\item \texttt{LINK\_ONCE\_DISCARD}: Ensures only one copy of the section is kept during linking.
\end{itemize}
\end{itemize}

\subparagraph{\textbf{2. \texttt{.text}}}

\begin{verbatim}
1 .text         0000002f  00000000  00000000  0000003c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
\end{verbatim}

\begin{itemize}
\item \textbf{Purpose}: Contains the executable code for the program.
\item \textbf{Attributes}:

\begin{itemize}
\item \texttt{CODE}: Contains machine instructions.
\item \texttt{READONLY}: Read-only section.
\item \texttt{RELOC}: Contains relocation entries for linking.
\end{itemize}
\end{itemize}

\subparagraph{\textbf{3. \texttt{.data}}}

\begin{verbatim}
2 .data         00000000  00000000  00000000  0000006b  2**0
                  CONTENTS, ALLOC, LOAD, DATA
\end{verbatim}

\begin{itemize}
\item \textbf{Purpose}: Contains initialized global and static variables.
\item \textbf{Attributes}:

\begin{itemize}
\item \texttt{DATA}: Contains data.
\item \texttt{ALLOC}: Allocated in memory during execution.
\end{itemize}
\end{itemize}

\subparagraph{\textbf{4. \texttt{.bss}}}

\begin{verbatim}
3 .bss          00000000  00000000  00000000  0000006b  2**0
                  ALLOC
\end{verbatim}

\begin{itemize}
\item \textbf{Purpose}: Contains uninitialized global and static variables.
\item \textbf{Attributes}:

\begin{itemize}
\item \texttt{ALLOC}: Allocated in memory during execution but not stored in the object file.
\end{itemize}
\end{itemize}

\subparagraph{\textbf{5. \texttt{.text.\_\_x86.get\_pc\_thunk.ax}}}

\begin{verbatim}
4 .text.__x86.get_pc_thunk.ax 00000004  00000000  00000000  0000006b  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
\end{verbatim}

\begin{itemize}
\item \textbf{Purpose}: Contains the helper function \texttt{\_\_x86.get\_pc\_thunk.ax}, used for position-independent code.
\item \textbf{Attributes}:

\begin{itemize}
\item \texttt{CODE}: Contains machine instructions.
\item \texttt{READONLY}: Read-only section.
\end{itemize}
\end{itemize}

\subparagraph{\textbf{6. \texttt{.comment}}}

\begin{verbatim}
5 .comment      00000028  00000000  00000000  0000006f  2**0
                  CONTENTS, READONLY
\end{verbatim}

\begin{itemize}
\item \textbf{Purpose}: Contains metadata about the compiler and build environment.
\item \textbf{Attributes}:

\begin{itemize}
\item \texttt{READONLY}: Read-only section.
\end{itemize}
\end{itemize}

\subparagraph{\textbf{7. \texttt{.note.gnu.property}}}

\begin{verbatim}
7 .note.gnu.property 00000028  00000000  00000000  00000098  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
\end{verbatim}

\begin{itemize}
\item \textbf{Purpose}: Contains properties for GNU tools, such as security features.
\item \textbf{Attributes}:

\begin{itemize}
\item \texttt{DATA}: Contains data.
\item \texttt{READONLY}: Read-only section.
\end{itemize}
\end{itemize}

\subparagraph{\textbf{8. \texttt{.eh\_frame}}}

\begin{verbatim}
8 .eh_frame     0000004c  00000000  00000000  000000c0  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
\end{verbatim}

\begin{itemize}
\item \textbf{Purpose}: Contains exception handling information for stack unwinding.
\item \textbf{Attributes}:

\begin{itemize}
\item \texttt{DATA}: Contains data.
\item \texttt{RELOC}: Contains relocation entries for linking.
\end{itemize}
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Symbol Table}}

\begin{verbatim}
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 mult_int.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .text.__x86.get_pc_thunk.ax	00000000 .text.__x86.get_pc_thunk.ax
00000000 g     F .text	0000002f main
00000000 g     F .text.__x86.get_pc_thunk.ax	00000000 .hidden __x86.get_pc_thunk.ax
00000000         *UND*	00000000 _GLOBAL_OFFSET_TABLE_
\end{verbatim}

\begin{itemize}
\item \textbf{Symbols}:

\begin{itemize}
\item \texttt{main}: The main function, located in the \texttt{.text} section.
\item \texttt{\_\_x86.get\_pc\_thunk.ax}: A helper function for position-independent code.
\item \texttt{\_GLOBAL\_OFFSET\_TABLE\_}: An undefined symbol used for dynamic linking.
\end{itemize}
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Disassembly}}

\subparagraph{\textbf{1. \texttt{.text} Section}}

\begin{verbatim}
00000000 <main>:
   0:	55                   	push   ebp
   1:	89 e5                	mov    ebp,esp
   3:	83 ec 10             	sub    esp,0x10
   6:	e8 fc ff ff ff       	call   7 <main+0x7>
			7: R_386_PC32	__x86.get_pc_thunk.ax
   b:	05 01 00 00 00       	add    eax,0x1
			c: R_386_GOTPC	_GLOBAL_OFFSET_TABLE_
  10:	c7 45 fc 02 00 00 00 	mov    DWORD PTR [ebp -0x4],0x2
  17:	c7 45 f8 03 00 00 00 	mov    DWORD PTR [ebp -0x8],0x3
  1e:	8b 45 fc             	mov    eax,DWORD PTR [ebp -0x4]
  21:	0f af 45 f8          	imul   eax,DWORD PTR [ebp -0x8]
  25:	89 45 f4             	mov    DWORD PTR [ebp -0xc],eax
  28:	b8 00 00 00 00       	mov    eax,0x0
  2d:	c9                   	leave
  2e:	c3                   	ret
\end{verbatim}

\begin{itemize}
\item This is the disassembled code for the \texttt{main} function. It matches the assembly code in the previous attachment:

\begin{itemize}
\item Sets up the stack frame.
\item Initializes variables \texttt{a} and \texttt{b}.
\item Multiplies \texttt{a} and \texttt{b} using the \texttt{imul} instruction.
\item Stores the result in \texttt{c}.
\item Returns \texttt{0}.
\end{itemize}
\end{itemize}

\subparagraph{\textbf{2. \texttt{.text.\_\_x86.get\_pc\_thunk.ax} Section}}

\begin{verbatim}
00000000 <__x86.get_pc_thunk.ax>:
   0:	8b 04 24             	mov    eax,DWORD PTR [esp]
   3:	c3                   	ret
\end{verbatim}

\begin{itemize}
\item This is the helper function \texttt{\_\_x86.get\_pc\_thunk.ax}, which retrieves the program counter (PC) value for position-independent code.
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Summary}}

This \texttt{objdump} output provides a detailed view of the object file \texttt{mult\_int.o}. It includes:

\begin{itemize}
\item Metadata about the file format and architecture.
\item Section details, including their purpose and attributes.
\item A symbol table listing functions and symbols.
\item Disassembled machine code for the \texttt{main} function and the helper function \texttt{\_\_x86.get\_pc\_thunk.ax}.
\end{itemize}

The \texttt{main} function performs integer multiplication (\texttt{a * b}) and returns \texttt{0}. The helper function supports position-independent code by retrieving the program counter.

\subparagraph{Project Code on GitHub}

Project code and resources can be found on my GitHub repository: \newline

\href{https://github.com/markkhusid/Disassembling-Binaries/tree/master/C/Intel\_architecture/i386/Integer\_Operations/Mult\_Int}{GitHub}