\begin{verbatim}
- - -
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
 - - -
\end{verbatim}

\subparagraph{Section: Bit Manipulations - Create Lookup Table}

Adapted from: \href{https://github.com/gjbex/Fortran-MOOC/tree/master/source\_code/bit\_manipulations}{https://github.com/gjbex/Fortran-MOOC/tree/master/source\_code/bit\_manipulations}

This program demonstrates bit manipulations using Fortran.

\subparagraph{Code Analysis by ChatGPT 4o: create\_lookup\_table.f90}

The provided Fortran program \texttt{create\_lookup\_table} performs the following tasks:

\subparagraph{Overview}

This program creates a lookup table of integers (256 entries) and writes it to a file specified as a command-line argument. The table is constructed to store the number of \texttt{1}s in the binary representation of integers from \texttt{0} to \texttt{255}. The program outputs the data into a formatted text file in groups of 16 integers per line.


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{Key Components}

\subparagraph{\textbf{1. Program Initialization}}

\begin{itemize}
\item The \texttt{use, intrinsic :: iso\_fortran\_env} imports constants such as \texttt{error\_unit}, which is used for error reporting.
\item \texttt{lookup\_table} is an integer array of size 256 to hold the lookup table values.
\item \texttt{file\_name} is a character string to store the file name provided by the user.
\item Various local variables (\texttt{unit\_nr}, \texttt{istat}, \texttt{msg}, etc.) are used for file operations.
\end{itemize}

\subparagraph{\textbf{2. Command-Line Argument Handling}}

\begin{itemize}
\item The program expects one command-line argument: the output file name.
\item It checks if exactly one argument is provided using \texttt{command\_argument\_count()}.
\item If the argument count is incorrect, it writes an error message to the \texttt{error\_unit} and stops execution.
\end{itemize}

\subparagraph{\textbf{3. Lookup Table Initialization}}

\begin{itemize}
\item A \texttt{contains} section defines the function \texttt{init\_lookup\_table}, which calculates the lookup table values.
\item Each entry in \texttt{lookup\_table(i)} represents the count of \texttt{1}s in the binary representation of the integer \texttt{i}.

\begin{itemize}
\item This is computed using the formula:

\begin{equation}
\text{lookup\_table}(i) = \text{AND}(i, 1) + \text{lookup\_table}(i/2)
\end{equation}


\item The formula exploits the fact that \texttt{i/2} shifts \texttt{i} one bit to the right, and \texttt{AND(i, 1)} extracts the least significant bit of \texttt{i}.
\end{itemize}
\end{itemize}

\subparagraph{\textbf{4. File Handling}}

\begin{itemize}
\item The file is opened using \texttt{open}, with the \texttt{newunit} option to get a unique file unit and \texttt{status='replace'} to overwrite the file if it exists.
\item If an error occurs during file opening, the program writes the error message stored in \texttt{iomsg} to the \texttt{error\_unit}.
\end{itemize}

\subparagraph{\textbf{5. Writing the Lookup Table}}

\begin{itemize}
\item The program writes the lookup table to the file in a formatted manner:

\begin{itemize}
\item It outputs 16 numbers per line for the first 15 lines, each separated by commas.
\item The 16th line writes the remaining 15 numbers (from index 240 to 255) and a final number (\texttt{lookup\_table(256)}).
\end{itemize}


\item Each line is indented for readability, and Fortran's continuation character (\texttt{\&}) is used for lines longer than the maximum line length.
\end{itemize}

\subparagraph{\textbf{6. Cleanup}}

\begin{itemize}
\item After writing the data, the file is closed.
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{Detailed Explanation of Functions and Constructs}

\subparagraph{\texttt{init\_lookup\_table}}

This function initializes the lookup table by calculating the number of \texttt{1}s in the binary representation of integers from \texttt{0} to \texttt{255}:

\begin{enumerate}
\item \texttt{lookup\_table(0) = 0}: The number \texttt{0} has no \texttt{1}s in its binary representation.
\item For each \texttt{i} from \texttt{1} to \texttt{255}, the formula computes the count of \texttt{1}s as:

\begin{itemize}
\item \texttt{and(i, 1)}: Checks if the least significant bit of \texttt{i} is \texttt{1}.
\item \texttt{lookup\_table(i/2)}: Uses the precomputed value of \texttt{i/2} to avoid redundant calculations.
\end{itemize}
\end{enumerate}

\subparagraph{Writing to File}

The formatted output is controlled by \texttt{write} statements:

\begin{itemize}
\item The main loop iterates over groups of 16 integers and formats them as:

\begin{verbatim}
0, 1, 1, 2, 1, 2, 2, 3, ...
\end{verbatim}


\item The last line is handled separately to avoid trailing commas.
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{Sample Output}

Assume the lookup table for the first 16 integers is as follows:

\begin{verbatim}
0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4
\end{verbatim}

The file might look like this:

\begin{verbatim}
0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, &
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, &
        ...
\end{verbatim}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{Error Handling}

\begin{itemize}
\item If no file name is provided, an error message is printed:

\begin{verbatim}
error: expecting file name as argument
\end{verbatim}


\item If file operations fail, an error message is printed with details of the issue.
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{Use Cases}

This program is useful for:

\begin{enumerate}
\item Generating lookup tables for bit-counting applications.
\item Demonstrating efficient table initialization using recursion.
\item Creating formatted output for use in other programs or as human-readable data.
\end{enumerate}

\subparagraph{Program Code}

\begin{verbatim}
program create_lookup_table
    use, intrinsic :: iso_fortran_env, only : error_unit
    implicit none
    integer, dimension(256) :: lookup_table
    character(len=1024) :: file_name, msg
    integer :: i, unit_nr, istat

    lookup_table = init_lookup_table()
    if (command_argument_count() /= 1) then
        write (unit=error_unit, fmt='(A)') 'error: expacting file name as argument'
        stop 1
    end if
    call get_command_argument(1, file_name)
    open (newunit=unit_nr, file=trim(file_name), status='replace', &
        access='sequential', form='formatted', iostat=istat, iomsg=msg)
    if (istat /= 0) then
        write (unit=error_unit, fmt='(2A)') 'error: ', trim(msg)
        stop 1
    end if
    do i = 1, 15
        write (unit=unit_nr, fmt='("        ", 16(I3, ","), " &")') &
            lookup_table((i - 1)*16 + 1:i*16) 
    end do
    write (unit=unit_nr, fmt='("        ", 15(I3, ","))', advance='no') &
                lookup_table(15*16 + 1:16*16 - 1) 
    write (unit=unit_nr, fmt='(I3, " &")') lookup_table(256)
    close (unit=unit_nr)

contains

    function init_lookup_table() result(lookup_table)
        implicit none
        integer, dimension(0:255) :: lookup_table
        integer :: i

        lookup_table(0) = 0
        do i = 1, 255
            lookup_table(i) = and(i, 1) + lookup_table(i/2)
        end do
    end function init_lookup_table

end program create_lookup_table
\end{verbatim}

The above program is compiled and run using Fortran Package Manager (fpm).  The following FPM configuration file (fpm.toml) was used:

\begin{verbatim}
name = "Section_Bit_Manipulations_Create_Lookup_Table"

[build]
auto -executables = true
auto -tests = true
auto -examples = true

[install]
library = false

[[executable]]
name="Section_Bit_Manipulations_Create_Lookup_Table"
source -dir="app"
main="section_bit_manipulations_create_lookup_table.f90"
\end{verbatim}

\subparagraph{Build the Program using FPM (Fortran Package Manager)}

\begin{verbatim}
import os
root_dir = ""
root_dir = os.getcwd()
\end{verbatim}

\begin{verbatim}
code_dir = root_dir + "/" + "Fortran_Code/Section_Bit_Manipulations_Create_Lookup_Table"
\end{verbatim}

\begin{verbatim}
os.chdir(code_dir)
\end{verbatim}

\begin{verbatim}
build_status = os.system("fpm build 2>/dev/null")
\end{verbatim}

\subparagraph{Run the Program using FPM (Fortran Package Manager)}

The program is run and the output is saved into a file named 'data.dat

\begin{verbatim}
exec_status = \
    os.system("fpm run - - lookup_table.dat 2>/dev/null")
\end{verbatim}

\subparagraph{Display the Output File}

\begin{verbatim}
exec_status = \
    os.system("cat lookup_table.dat")
\end{verbatim}

\begin{verbatim}
0,  1,  1,  2,  1,  2,  2,  3,  1,  2,  2,  3,  2,  3,  3,  4, &
          1,  2,  2,  3,  2,  3,  3,  4,  2,  3,  3,  4,  3,  4,  4,  5, &
          1,  2,  2,  3,  2,  3,  3,  4,  2,  3,  3,  4,  3,  4,  4,  5, &
          2,  3,  3,  4,  3,  4,  4,  5,  3,  4,  4,  5,  4,  5,  5,  6, &
          1,  2,  2,  3,  2,  3,  3,  4,  2,  3,  3,  4,  3,  4,  4,  5, &
          2,  3,  3,  4,  3,  4,  4,  5,  3,  4,  4,  5,  4,  5,  5,  6, &
          2,  3,  3,  4,  3,  4,  4,  5,  3,  4,  4,  5,  4,  5,  5,  6, &
          3,  4,  4,  5,  4,  5,  5,  6,  4,  5,  5,  6,  5,  6,  6,  7, &
          1,  2,  2,  3,  2,  3,  3,  4,  2,  3,  3,  4,  3,  4,  4,  5, &
          2,  3,  3,  4,  3,  4,  4,  5,  3,  4,  4,  5,  4,  5,  5,  6, &
          2,  3,  3,  4,  3,  4,  4,  5,  3,  4,  4,  5,  4,  5,  5,  6, &
          3,  4,  4,  5,  4,  5,  5,  6,  4,  5,  5,  6,  5,  6,  6,  7, &
          2,  3,  3,  4,  3,  4,  4,  5,  3,  4,  4,  5,  4,  5,  5,  6, &
          3,  4,  4,  5,  4,  5,  5,  6,  4,  5,  5,  6,  5,  6,  6,  7, &
          3,  4,  4,  5,  4,  5,  5,  6,  4,  5,  5,  6,  5,  6,  6,  7, &
          4,  5,  5,  6,  5,  6,  6,  7,  5,  6,  6,  7,  6,  7,  7,  8 &
\end{verbatim}