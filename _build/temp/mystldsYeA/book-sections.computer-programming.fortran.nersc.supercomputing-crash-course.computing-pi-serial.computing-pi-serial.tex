\begin{verbatim}
- - -
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
 - - -
\end{verbatim}

\subparagraph{Crash Course in Supercomputing: Compute Pi in a Serial Fashion}

Adapted from: \href{https://github.com/NERSC/crash-course-supercomputing/tree/main/darts-suite/fortran}{https://github.com/NERSC/crash-course-supercomputing/tree/main/darts-suite/fortran}

\subparagraph{This program demonstrates computing $\pi$ in Fortran using the Monte Carlo method in a Serial Fashion:}

\subparagraph{In file computing\_pi\_serial.f90}

\begin{verbatim}
! Compute pi in serial
program compute_pi_serial
  use, intrinsic :: iso_fortran_env, only : DP => REAL64, I8 => INT64
  use lcgenerator_mod,  only : lcgrandom
  use get_nr_iters_mod, only : get_nr_iters
  
  implicit none

  integer(kind=I8) :: num_trials, i = 0, Ncirc = 0
  real(kind=DP) :: pi_computed = 0.0, pi_actual
  real(kind=DP) :: x = 0.0, y = 0.0, r = 1.0
  real(kind=DP) :: r_squared = 0.0

  pi_actual = 2.0_DP * acos(0.0_DP)
  
  r_squared = r*r

  num_trials = get_nr_iters()

  do i = 1, num_trials
    x = lcgrandom()
    y = lcgrandom()
    if ((x*x + y*y) <= r_squared) then
        Ncirc = Ncirc + 1
    end if
  end do

  pi_computed = 4.0*((1.0*Ncirc)/(1.0*num_trials))

  print '(A, I10, A, F25.15)', "After ", num_trials, " loops, Pi = ", pi_computed
  print '(A, F25.15)', "Actual value of Pi = ", pi_actual
  print '(A, F25.15)', "Absolute difference = ", abs(pi_computed - pi_actual)

end program compute_pi_serial
\end{verbatim}

\subparagraph{In the file lcgenerator\_mod.f90}

\begin{verbatim}
module lcgenerator_mod
  use, intrinsic :: iso_fortran_env, only : DP => REAL64, I8 => INT64
  implicit none
  private
  public :: lcgrandom

  contains
    real function lcgrandom()
      integer(kind=I8), parameter :: MULTIPLIER = 1366
      integer(kind=I8), parameter :: ADDEND = 150889
      integer(kind=I8), parameter :: PMOD = 714025
      integer(kind=I8), save :: random_last = 0

      integer(kind=I8) :: random_next = 0
      random_next = mod((MULTIPLIER * random_last + ADDEND), PMOD)
      random_last = random_next
      lcgrandom = (1.0_DP * random_next) / PMOD
      return
    end function lcgrandom
end module lcgenerator_mod
\end{verbatim}

\subparagraph{In the file get\_nr\_iters\_mod.f90}

\begin{verbatim}
module get_nr_iters_mod
    implicit none
    private
    public :: get_nr_iters

contains

    function get_nr_iters() result(nr_iters)
        use, intrinsic :: iso_fortran_env, only : error_unit
        use, intrinsic :: iso_fortran_env, only : DP => REAL64, I8 => INT64
        implicit none
        integer(kind=I8) :: nr_iters
        integer(kind=I8), parameter :: default_nr_iters = 1000_I8
        character(len=1024) :: buffer, msg
        integer :: istat

        if (command_argument_count() >= 1) then
            call get_command_argument(1, buffer)
            read (buffer, fmt=*, iostat=istat, iomsg=msg) nr_iters
            if (istat /= 0) then
                write (unit=error_unit, fmt='(2A)') &
                    'error: ', msg
                stop 1
            end if
        else
            nr_iters = default_nr_iters
        end if
    end function get_nr_iters

end module get_nr_iters_mod
\end{verbatim}

\subparagraph{Code Analysis by Grok 4}

\subparagraph{Overview of the Code}

This Fortran code is a complete, self-contained program designed to approximate the value of $\pi$ (pi) using the Monte Carlo simulation method. The approach is serial (non-parallel), meaning it runs sequentially on a single processor without any concurrency. The program generates pseudo-random points within a unit square and counts how many fall inside a quarter-circle inscribed in that square. The ratio of points inside the circle to the total points, multiplied by 4, provides an estimate of $\pi$.

The code is structured as a main program (\texttt{compute\_pi\_serial}) and two supporting modules:

\begin{itemize}
\item \texttt{get\_nr\_iters\_mod}: Handles reading the number of iterations (trials) from command-line arguments or uses a default value.
\item \texttt{lcgenerator\_mod}: Provides a simple linear congruential generator (LCG) for pseudo-random number generation.
\end{itemize}

The code uses modern Fortran features (e.g., from Fortran 2008/2018 standards), including intrinsic modules like \texttt{iso\_fortran\_env} for portable data types (e.g., 64-bit reals and integers). It employs double-precision arithmetic for accuracy and includes error handling for input.

I'll explain the code in detail, breaking it down by section: first the main program, then each module. I'll cover the purpose, syntax, variables, logic, and any key Fortran concepts.

\subparagraph{Main Program: \texttt{compute\_pi\_serial}}

This is the entry point of the executable. It sets up the simulation, runs the Monte Carlo loop, computes the approximation, and prints results.

\begin{verbatim}
program compute_pi_serial
  use, intrinsic :: iso_fortran_env, only : DP => REAL64, I8 => INT64
  use lcgenerator_mod,  only : lcgrandom
  use get_nr_iters_mod, only : get_nr_iters
  
  implicit none

  integer(kind=I8) :: num_trials, i = 0, Ncirc = 0
  real(kind=DP) :: pi_computed = 0.0, pi_actual
  real(kind=DP) :: x = 0.0, y = 0.0, r = 1.0
  real(kind=DP) :: r_squared = 0.0

  pi_actual = 2.0_DP * acos(0.0_DP)
  
  r_squared = r*r

  num_trials = get_nr_iters()

  do i = 1, num_trials
    x = lcgrandom()
    y = lcgrandom()
    if ((x*x + y*y) <= r_squared) then
        Ncirc = Ncirc + 1
    end if
  end do

  pi_computed = 4.0*((1.0*Ncirc)/(1.0*num_trials))

  print '(A, I10, A, F25.15)', "After ", num_trials, " loops, Pi = ", pi_computed
  print '(A, F25.15)', "Actual value of Pi = ", pi_actual
  print '(A, F25.15)', "Absolute difference = ", abs(pi_computed - pi_actual)

end program compute_pi_serial
\end{verbatim}

\subparagraph{Breakdown:}

\begin{enumerate}
\item \textbf{Module Imports and Aliases}:

\begin{itemize}
\item \texttt{use, intrinsic :: iso\_fortran\_env, only : DP =\textgreater  REAL64, I8 =\textgreater  INT64}: This imports the intrinsic module \texttt{iso\_fortran\_env}, which provides portable kind parameters for data types. \texttt{DP} is aliased to \texttt{REAL64} (64-bit double-precision real), and \texttt{I8} to \texttt{INT64} (64-bit integer). This ensures cross-platform consistency for high-precision calculations.
\item \texttt{use lcgenerator\_mod, only : lcgrandom}: Imports the \texttt{lcgrandom} function from the \texttt{lcgenerator\_mod} module for generating pseudo-random numbers.
\item \texttt{use get\_nr\_iters\_mod, only : get\_nr\_iters}: Imports the \texttt{get\_nr\_iters} function from the \texttt{get\_nr\_iters\_mod} module to determine the number of trials.
\item \texttt{implicit none}: A good practice in Fortran to prevent undeclared variables; all variables must be explicitly declared.
\end{itemize}


\item \textbf{Variable Declarations}:

\begin{itemize}
\item \texttt{integer(kind=I8) :: num\_trials, i = 0, Ncirc = 0}: Declares 64-bit integers:

\begin{itemize}
\item \texttt{num\_trials}: Total number of Monte Carlo trials (points to generate).
\item \texttt{i}: Loop counter, initialized to 0.
\item \texttt{Ncirc}: Counter for points inside the quarter-circle, initialized to 0.
\end{itemize}


\item \texttt{real(kind=DP) :: pi\_computed = 0.0, pi\_actual}: Double-precision reals:

\begin{itemize}
\item \texttt{pi\_computed}: The approximated value of $\pi$.
\item \texttt{pi\_actual}: The ``true'' value of $\pi$ (computed using \texttt{acos}).
\end{itemize}


\item \texttt{real(kind=DP) :: x = 0.0, y = 0.0, r = 1.0}: Coordinates and radius:

\begin{itemize}
\item \texttt{x}, \texttt{y}: Pseudo-random coordinates in [0,1).
\item \texttt{r}: Radius of the circle (fixed at 1.0 for a unit circle).
\end{itemize}


\item \texttt{real(kind=DP) :: r\_squared = 0.0}: Precomputed \texttt{r*r} (1.0) to avoid repeated multiplication in the loop for minor efficiency.
\end{itemize}


\item \textbf{Computing the Actual $\pi$}:

\begin{itemize}
\item \texttt{pi\_actual = 2.0\_DP * acos(0.0\_DP)}: Uses the intrinsic \texttt{acos} function (arc cosine) to compute $\pi$. \texttt{acos(0.0)} returns $\pi$/2, so multiplying by 2 gives $\pi$. The \texttt{\_DP} suffix ensures double-precision literals.
\end{itemize}


\item \textbf{Precomputing r\_squared}:

\begin{itemize}
\item \texttt{r\_squared = r*r}: Stores 1.0 for use in the distance check inside the loop.
\end{itemize}


\item \textbf{Getting Number of Trials}:

\begin{itemize}
\item \texttt{num\_trials = get\_nr\_iters()}: Calls the function from \texttt{get\_nr\_iters\_mod} to read the number of iterations. If no command-line argument is provided, it defaults to 1000.
\end{itemize}


\item \textbf{Monte Carlo Loop}:

\begin{itemize}
\item \texttt{do i = 1, num\_trials}: A simple do-loop that runs \texttt{num\_trials} times.

\begin{itemize}
\item \texttt{x = lcgrandom()}: Generates a pseudo-random number in [0,1) for the x-coordinate.
\item \texttt{y = lcgrandom()}: Same for y-coordinate.
\item \texttt{if ((x*x + y*y) \textless = r\_squared) then}: Checks if the point (x,y) is inside the quarter-circle by testing if the squared distance from origin (x\textsuperscript{2} + y\textsuperscript{2}) $\leq$ 1.0.

\begin{itemize}
\item If true, \texttt{Ncirc = Ncirc + 1}: Increments the counter.
\end{itemize}
\end{itemize}


\item This implements the core Monte Carlo method: the probability a random point in the unit square falls inside the quarter-circle is $\pi$/4, so $\pi$ $\approx$ 4 * (Ncirc / num\_trials).
\end{itemize}


\item \textbf{Computing the Approximation}:

\begin{itemize}
\item \texttt{pi\_computed = 4.0*((1.0*Ncirc)/(1.0*num\_trials))}: Calculates the estimate. The \texttt{1.0*} ensures real division (avoiding integer truncation). Note: In modern Fortran, this could be simplified to \texttt{4.0 * real(Ncirc, DP) / real(num\_trials, DP)}, but the code uses explicit promotion.
\end{itemize}


\item \textbf{Output}:

\begin{itemize}
\item \texttt{print '(A, I10, A, F25.15)', "After ", num\_trials, " loops, Pi = ", pi\_computed}: Prints the result with 10 digits for the integer and 15 decimal places for the float.
\item Similar prints for the actual $\pi$ and absolute difference (\texttt{abs(pi\_computed - pi\_actual)}).
\item Format specifiers: \texttt{A} for strings, \texttt{I10} for integers (width 10), \texttt{F25.15} for floats (width 25, 15 decimals).
\end{itemize}
\end{enumerate}

This main program is straightforward and efficient for small \texttt{num\_trials}, but for large values (e.g., millions), the approximation improves, though runtime increases linearly.

\subparagraph{Module: \texttt{get\_nr\_iters\_mod}}

This module provides a function to parse the number of iterations from command-line arguments, with error handling and a default value.

\begin{verbatim}
module get_nr_iters_mod
    implicit none
    private
    public :: get_nr_iters

contains

    function get_nr_iters() result(nr_iters)
        use, intrinsic :: iso_fortran_env, only : error_unit
        use, intrinsic :: iso_fortran_env, only : DP => REAL64, I8 => INT64
        implicit none
        integer(kind=I8) :: nr_iters
        integer(kind=I8), parameter :: default_nr_iters = 1000_I8
        character(len=1024) :: buffer, msg
        integer :: istat

        if (command_argument_count() >= 1) then
            call get_command_argument(1, buffer)
            read (buffer, fmt=*, iostat=istat, iomsg=msg) nr_iters
            if (istat /= 0) then
                write (unit=error_unit, fmt='(2A)') &
                    'error: ', msg
                stop 1
            end if
        else
            nr_iters = default_nr_iters
        end if
    end function get_nr_iters

end module get_nr_iters_mod
\end{verbatim}

\subparagraph{Breakdown:}

\begin{enumerate}
\item \textbf{Module Structure}:

\begin{itemize}
\item \texttt{implicit none}: No implicit typing.
\item \texttt{private}: All entities are private by default.
\item \texttt{public :: get\_nr\_iters}: Only the function is exposed.
\end{itemize}


\item \textbf{Function \texttt{get\_nr\_iters}}:

\begin{itemize}
\item Returns an \texttt{integer(kind=I8)}: The number of iterations.
\item Imports: Re-imports \texttt{iso\_fortran\_env} for \texttt{error\_unit} (standard error stream) and types.
\item \texttt{integer(kind=I8), parameter :: default\_nr\_iters = 1000\_I8}: Constant default value with \texttt{\_I8} kind suffix.
\item Variables: \texttt{buffer} (string to hold argument), \texttt{msg} (error message), \texttt{istat} (I/O status).
\end{itemize}


\item \textbf{Logic}:

\begin{itemize}
\item \texttt{if (command\_argument\_count() \textgreater = 1) then}: Checks if at least one command-line argument exists (using intrinsic \texttt{command\_argument\_count}).

\begin{itemize}
\item \texttt{call get\_command\_argument(1, buffer)}: Retrieves the first argument into \texttt{buffer}.
\item \texttt{read (buffer, fmt=*, iostat=istat, iomsg=msg) nr\_iters}: Parses the string as an integer (free-format \texttt{*}).

\begin{itemize}
\item If \texttt{istat /= 0} (error), prints to stderr and stops with exit code 1.
\end{itemize}
\end{itemize}


\item Else: Uses default 1000.
\end{itemize}
\end{enumerate}

This makes the program flexible: run as \texttt{./compute\_pi\_serial 1000000} for 1 million trials.

\subparagraph{Module: \texttt{lcgenerator\_mod}}

This module implements a basic linear congruential generator (LCG) for pseudo-random numbers in [0,1).

\begin{verbatim}
module lcgenerator_mod
  use, intrinsic :: iso_fortran_env, only : DP => REAL64, I8 => INT64
  implicit none
  private
  public :: lcgrandom

  contains
    real function lcgrandom()
      integer(kind=I8), parameter :: MULTIPLIER = 1366
      integer(kind=I8), parameter :: ADDEND = 150889
      integer(kind=I8), parameter :: PMOD = 714025
      integer(kind=I8), save :: random_last = 0

      integer(kind=I8) :: random_next = 0
      random_next = mod((MULTIPLIER * random_last + ADDEND), PMOD)
      random_last = random_next
      lcgrandom = (1.0_DP * random_next) / PMOD
      return
    end function lcgrandom
end module lcgenerator_mod
\end{verbatim}

\subparagraph{Breakdown:}

\begin{enumerate}
\item \textbf{Module Structure}:

\begin{itemize}
\item Imports types from \texttt{iso\_fortran\_env}.
\item \texttt{implicit none}, \texttt{private}, \texttt{public :: lcgrandom}: Similar to the previous module.
\end{itemize}


\item \textbf{Function \texttt{lcgrandom}}:

\begin{itemize}
\item Returns a \texttt{real} (implicitly double-precision via context).
\item Parameters: LCG constants (multiplier a=1366, increment c=150889, modulus m=714025). These are from older literature (e.g., IBM RANDU-like, but custom).
\item \texttt{integer(kind=I8), save :: random\_last = 0}: Static variable (via \texttt{save}) to hold the previous state (seed). Initializes to 0 on first call.
\end{itemize}


\item \textbf{Logic}:

\begin{itemize}
\item \texttt{random\_next = mod((MULTIPLIER * random\_last + ADDEND), PMOD)}: Core LCG formula: X\_\{n+1\} = (a * X\_n + c) mod m.

\begin{itemize}
\item Uses \texttt{mod} for modulo operation.
\end{itemize}


\item \texttt{random\_last = random\_next}: Updates the state for the next call.
\item \texttt{lcgrandom = (1.0\_DP * random\_next) / PMOD}: Normalizes to [0,1) by dividing by m (promoting to real).
\item \texttt{return}: Explicit return (optional in Fortran).
\end{itemize}
\end{enumerate}

This LCG is simple and deterministic (same sequence every run due to fixed seed). It's not cryptographically secure or highly random but sufficient for this simulation. For better randomness, modern codes might use Fortran's \texttt{random\_number} intrinsic, but this demonstrates a custom generator.

\subparagraph{Key Concepts and Notes}

\begin{itemize}
\item \textbf{Monte Carlo Method}: Statistical sampling to approximate $\pi$. Accuracy improves with more trials (O(1/sqrt(N)) convergence), but it's probabilistic---results vary per run due to randomness.
\item \textbf{Fortran-Specifics}:

\begin{itemize}
\item Modules promote modularity and encapsulation.
\item Kind parameters ensure portability.
\item No explicit main; the \texttt{program} block is the executable.
\end{itemize}


\item \textbf{Compilation/Running}: Compile with \texttt{gfortran compute\_pi\_serial.f90} (assuming all in one file). Run with optional argument for trials.
\item \textbf{Limitations}: LCG period is at most m=714025, so for very large \texttt{num\_trials}, it repeats. Not thread-safe (due to shared \texttt{save} variable).
\item \textbf{Extensions}: Could be parallelized with OpenMP for multi-core speedup.
\end{itemize}

This code is educational, demonstrating numerical methods, I/O, and modular design in Fortran.

\subparagraph{Code Analysis by ChatGPT 5 Thinking}

\subparagraph{What the code does (high-level)}

This is a \textbf{serial Monte-Carlo estimator for $\pi$}. It repeatedly draws uniform random points $(x,y)\in[0,1)\times[0,1)$ and counts how many fall inside the quarter of a unit circle, i.e., where $x^2+y^2\le 1$. If $N$ points are drawn and $N_{\text{circ}}$ are inside, the estimator is

\begin{equation}
\widehat{\pi}=4\,\frac{N_{\text{circ}}}{N}.
\end{equation}

Two small modules support the program:

\begin{itemize}
\item \texttt{lcgenerator\_mod.f90}: a tiny \textbf{linear congruential generator (LCG)} returning a uniform variate in $[0,1)$.
\item \texttt{get\_nr\_iters\_mod.f90}: parses the \textbf{first command-line argument} as the number of trials (with a default if omitted).
\end{itemize}

Below I walk through each file in detail, explain the Fortran choices (kinds, intrinsics, I/O), and then point out \textbf{two important correctness/quality issues} and offer drop-in fixes.


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{File-by-file explanation}

\subparagraph{1) \texttt{compute\_pi\_serial.f90} --- main program}

\subparagraph{Modules and kinds}

\begin{verbatim}
program compute_pi_serial
  use, intrinsic :: iso_fortran_env, only : DP => REAL64, I8 => INT64
  use lcgenerator_mod,  only : lcgrandom
  use get_nr_iters_mod, only : get_nr_iters
\end{verbatim}

\begin{itemize}
\item \texttt{iso\_fortran\_env} provides \textbf{portably sized kinds}. Here:

\begin{itemize}
\item \texttt{DP} aliases \texttt{REAL64} (IEEE double precision),
\item \texttt{I8} aliases \texttt{INT64} (signed 64-bit integer).
\end{itemize}


\item Importing just the names you use (\texttt{onlyï¼š\dots}) keeps the namespace clean and the intent explicit.
\end{itemize}

\subparagraph{Declarations and initialization}

\begin{verbatim}
integer(kind=I8) :: num_trials, i = 0, Ncirc = 0
  real(kind=DP) :: pi_computed = 0.0, pi_actual
  real(kind=DP) :: x = 0.0, y = 0.0, r = 1.0
  real(kind=DP) :: r_squared = 0.0

  pi_actual = 2.0_DP * acos(0.0_DP)
  r_squared = r*r
\end{verbatim}

\begin{itemize}
\item \texttt{num\_trials} is the total number of Monte-Carlo samples (draws).
\item \texttt{Ncirc} counts hits inside the quarter circle.
\item \texttt{pi\_actual} is computed as $2\arccos(0)=\pi$ in double precision; this avoids hard-coding a constant and is \textbf{portable} across compilers.
\item \texttt{r=1} and \texttt{r\_squared=1} define the unit circle.
\end{itemize}

\begin{quote}
\textbf{Minor omission to fix:} the program should \textit{set} \texttt{num\_trials} by calling \texttt{get\_nr\_iters()} before the loop (see ``Corrections \& improvements'').
\end{quote}

\subparagraph{Core Monte-Carlo loop}

\begin{verbatim}
do i = 1, num_trials
    x = lcgrandom()
    y = lcgrandom()
    if ((x*x + y*y) <= r_squared) then
        Ncirc = Ncirc + 1
    end if
  end do
\end{verbatim}

\begin{itemize}
\item Each iteration draws two independent uniform(0,1) variates.
\item The predicate \texttt{x*x + y*y \textless = 1.0} tests membership in the quarter circle.
\item Work and memory are \textbf{$O(N)$} and \textbf{$O(1)$} respectively.
\end{itemize}

\subparagraph{Estimator and output}

\begin{verbatim}
pi_computed = 4.0*((1.0*Ncirc)/(1.0*num_trials))

  print '(A, I10, A, F25.15)', "After ", num_trials, " loops, Pi = ", pi_computed
  print '(A, F25.15)', "Actual value of Pi = ", pi_actual
  print '(A, F25.15)', "Absolute difference = ", abs(pi_computed - pi_actual)
\end{verbatim}

\begin{itemize}
\item The estimator is $4\cdot N_{\text{circ}}/N$.
\item Formatting:

\begin{itemize}
\item \texttt{'I10'} prints a right-justified integer (width 10).
\item \texttt{'F25.15'} prints a real number with total width 25 and 15 digits after the decimal point.
\end{itemize}
\end{itemize}

\begin{quote}
\textbf{Type-precision note:} literals \texttt{4.0} and \texttt{1.0} are \textbf{default real} (usually 32-bit). The arithmetic will still be upcast when stored into a \texttt{REAL64} variable, but you lose precision in the intermediate steps. Prefer the \texttt{\_DP} suffix and/or explicit \texttt{real(...,kind=DP)} casts (see fixes below).
\end{quote}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{2) \texttt{lcgenerator\_mod.f90} --- Linear congruential generator}

\begin{verbatim}
module lcgenerator_mod
  use, intrinsic :: iso_fortran_env, only : DP => REAL64, I8 => INT64
  implicit none
  private
  public :: lcgrandom
\end{verbatim}

\begin{itemize}
\item \texttt{private} by default shields internal names; only the function \texttt{lcgrandom} is exported.
\end{itemize}

\begin{verbatim}
contains
  real function lcgrandom()
    integer(kind=I8), parameter :: MULTIPLIER = 1366
    integer(kind=I8), parameter :: ADDEND = 150889
    integer(kind=I8), parameter :: PMOD = 714025
    integer(kind=I8), save :: random_last = 0
\end{verbatim}

\begin{itemize}
\item This encodes the classic LCG recurrence

\begin{equation}
X_{n+1} = (a X_n + c) \bmod m
\end{equation}

with $a=1366$, $c=150{,}889$, $m=714{,}025$.


\item \texttt{save} makes \texttt{random\_last} \textbf{static state} across calls.
\end{itemize}

\begin{verbatim}
integer(kind=I8) :: random_next = 0
    random_next = mod((MULTIPLIER * random_last + ADDEND), PMOD)
    random_last = random_next
    lcgrandom = (1.0_DP * random_next) / PMOD
    return
  end function lcgrandom
end module lcgenerator_mod
\end{verbatim}

\begin{itemize}
\item The scaled output $\in[0,1)$ is computed as \texttt{random\_next / PMOD}.
\item Using \texttt{1.0\_DP * random\_next} forces the numerator to \texttt{REAL64}. However, \textbf{the function itself is declared as default \texttt{real}}, so the result is immediately \textbf{down-cast} to single precision upon return. See the fix below.
\end{itemize}

\textbf{Quality and period.} With $m=714{,}025$ the \textbf{maximum period is $m$}; after {\textasciitilde}7$\times$10\^5 calls the sequence repeats. For large Monte-Carlo runs this is weak. Also, these parameters are not among the better-studied modern LCGs. This is fine pedagogically, but I would not use it for serious statistical work.

\textbf{Reproducibility \& seeding.} The generator \textbf{always starts at 0}, hence it is fully deterministic and reproducible across runs and compilers. You might want to add a seeding interface if you want variability.

\textbf{Thread safety.} The \texttt{save}d global state means \textbf{not thread-safe}. It's fine here (the program is serial).


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{3) \texttt{get\_nr\_iters\_mod.f90} --- parse number of trials}

\begin{verbatim}
module get_nr_iters_mod
  implicit none
  private
  public :: get_nr_iters
contains

  function get_nr_iters() result(nr_iters)
    use, intrinsic :: iso_fortran_env, only : error_unit
    use, intrinsic :: iso_fortran_env, only : DP => REAL64, I8 => INT64
    implicit none
    integer(kind=I8) :: nr_iters
    integer(kind=I8), parameter :: default_nr_iters = 1000_I8
    character(len=1024) :: buffer, msg
    integer :: istat
\end{verbatim}

\begin{itemize}
\item The interface is simple: \textbf{no arguments}; returns an \texttt{INT64} count.
\item A default of \textbf{1000} iterations is provided.
\end{itemize}

\begin{verbatim}
if (command_argument_count() >= 1) then
        call get_command_argument(1, buffer)
        read (buffer, fmt=*, iostat=istat, iomsg=msg) nr_iters
        if (istat /= 0) then
            write (unit=error_unit, fmt='(2A)') 'error: ', msg
            stop 1
        end if
    else
        nr_iters = default_nr_iters
    end if
  end function get_nr_iters
end module get_nr_iters_mod
\end{verbatim}

\begin{itemize}
\item Uses \textbf{deferred format read} (\texttt{fmt=*}) to parse the first argument into \texttt{nr\_iters}.
\item On parse failure, it writes a helpful message to the \textbf{standard error unit} and exits with non-zero status (\texttt{stop 1}).
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{Statistical properties of the estimator (why it works)}

Let $Z_i=\mathbf{1}\{X_i^2+Y_i^2\le 1\}$ be i.i.d. Bernoulli with $p=\Pr(Z=1)=\text{Area}( \{x^2+y^2\le 1\}\cap[0,1]^2)=\pi/4$. Then

\begin{equation}
\widehat{\pi}=4\,\bar Z,\quad
\mathbb{E}[\widehat{\pi}]=\pi,\quad
\operatorname{Var}(\widehat{\pi})=\frac{16}{N}p(1-p)\approx\frac{2.6968}{N}.
\end{equation}

So the \textbf{standard deviation} is $\approx 1.642/\sqrt{N}$. As rules of thumb:

\begin{itemize}
\item $N=10^3$ \Rightarrow typical absolute error $\sim 5.2\times 10^{ -2}$.
\item $N=10^6$ \Rightarrow $\sim 1.6\times 10^{ -3}$.
\end{itemize}

Monte-Carlo converges as $O(N^{ -1/2})$; parallelizing increases $N$ faster, but you cannot beat this rate without variance-reduction tricks.


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{Corrections \& precision improvements (recommended)}

There are three easy fixes that make the program numerically cleaner and compile-ready.

\subparagraph{A) Set \texttt{num\_trials} (and remove the stray \texttt{...} line)}

Your \texttt{compute\_pi\_serial.f90} contains a literal line with \texttt{...} between \texttt{r\_squared = r*r} and the loop. That will not compile. Replace that region with a call to \texttt{get\_nr\_iters()}:

\begin{verbatim}
r_squared = r*r

  ! Parse N from the command line (default 1000 if absent)
  num_trials = get_nr_iters()
\end{verbatim}

\subparagraph{B) Keep all arithmetic in double precision}

\begin{itemize}
\item Make the RNG return \texttt{REAL64}.
\item Use double-precision literals and explicit casts in the estimator.
\end{itemize}

\textbf{In \texttt{lcgenerator\_mod.f90}:}

\begin{verbatim}
real(kind=DP) function lcgrandom()
    ...
    lcgrandom = real(random_next, kind=DP) / real(PMOD, kind=DP)
\end{verbatim}

\textbf{In \texttt{compute\_pi\_serial.f90}:}

\begin{verbatim}
pi_computed = 4.0_DP * real(Ncirc, kind=DP) / real(num_trials, kind=DP)
\end{verbatim}

This avoids any intermediate rounding to single precision.

\subparagraph{C) Optional: guard against bad inputs}

You can reject non-positive \texttt{num\_trials}:

\begin{verbatim}
if (num_trials <= 0_I8) then
    write(*,*) "num_trials must be positive"
    stop 1
  end if
\end{verbatim}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{Suggested polished version of \texttt{compute\_pi\_serial.f90}}

\begin{verbatim}
program compute_pi_serial
  use, intrinsic :: iso_fortran_env, only : DP => REAL64, I8 => INT64
  use lcgenerator_mod,  only : lcgrandom
  use get_nr_iters_mod, only : get_nr_iters
  implicit none

  integer(I8) :: num_trials, i, Ncirc
  real(DP)    :: pi_computed, pi_actual
  real(DP)    :: x, y, r, r_squared

  ! Initialize
  Ncirc      = 0_I8
  pi_computed= 0.0_DP
  pi_actual  = 2.0_DP * acos(0.0_DP)     ! = \pi
  r          = 1.0_DP
  r_squared  = r*r
  num_trials = get_nr_iters()

  if (num_trials <= 0_I8) stop "num_trials must be positive"

  do i = 1_I8, num_trials
    x = lcgrandom()
    y = lcgrandom()
    if (x*x + y*y <= r_squared) Ncirc = Ncirc + 1_I8
  end do

  pi_computed = 4.0_DP * real(Ncirc,kind=DP) / real(num_trials,kind=DP)

  print '(A, I12, A, F25.15)', "After ", num_trials, " loops, Pi = ", pi_computed
  print '(A, F25.15)',         "Actual value of Pi = ", pi_actual
  print '(A, F25.15)',         "Absolute difference = ", abs(pi_computed - pi_actual)
end program compute_pi_serial
\end{verbatim}

And in \texttt{lcgenerator\_mod.f90}, change the function line to:

\begin{verbatim}
real(kind=DP) function lcgrandom()
\end{verbatim}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{How to build and run}

\begin{verbatim}
# Build (gfortran example)
gfortran -std=f2008 -O3 lcgenerator_mod.f90 get_nr_iters_mod.f90 compute_pi_serial.f90 -o compute_pi_serial

# Run with 1,000,000 samples
./compute_pi_serial 1000000
\end{verbatim}

You should see an estimate within {\textasciitilde}$1.6\times 10^{ -3}$ of $\pi$ on a typical run (with this LCG it will be deterministic per the current code).


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{Further remarks \& optional enhancements}

\begin{itemize}
\item \textbf{RNG quality/period.} The modulus $m=714{,}025$ caps the period at $m$. If you run more draws than that, the sequence repeats. For higher-quality randomness, either use the Fortran intrinsic \texttt{random\_number} (simple, portable) or a 48- or 64-bit LCG/PCG with well-vetted parameters.
\item \textbf{Seeding.} Add a \texttt{seed\_lcg(seed)} routine that sets \texttt{random\_last}, and accept a 2nd CLI argument to seed runs.
\item \textbf{Performance.} In tight loops, the \texttt{mod} on 64-bit integers is the main cost. For serious speed you might:

\begin{itemize}
\item keep \texttt{random\_last} and constants in 64-bit and choose $m=2^{k}$ so modulo is a mask, or
\item batch-generate variates and test multiple points per iteration (SIMD).
\end{itemize}


\item \textbf{Parallelization.} The serial algorithm is embarrassingly parallel. If you later add OpenMP/MPI, ensure each thread/process gets an \textbf{independent RNG stream} (e.g., leapfrogging or distinct seeds with skip-ahead).
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

If you'd like, I can produce a version that uses the standard \texttt{random\_number} (for quality) and a command-line seed, plus a tiny unit test to verify the variance scaling.

The above program and modules are compiled and run using Fortran Package Manager (fpm):

\subparagraph{Build the Program using FPM (Fortran Package Manager)}

\begin{verbatim}
import os
root_dir = ""
root_dir = os.getcwd()
\end{verbatim}

The following configuration file (fpm.toml) was used:

\begin{verbatim}
name = "Compute_Pi_Serial"

[build]
auto -executables = true
auto -tests = true
auto -examples = true
module -naming = false

[install]
library = false
test = false

[fortran]
implicit -typing = false
implicit -external = false
source -form = "free"

[[executable]]
name = "compute_pi_serial"
source -dir = "app"
main = "compute_pi_serial.f90"
\end{verbatim}

\begin{verbatim}
code_dir = root_dir + "/" + "code"
\end{verbatim}

\begin{verbatim}
os.chdir(code_dir)
\end{verbatim}

\begin{verbatim}
build_status = os.system("fpm build 2>/dev/null")
\end{verbatim}

\subparagraph{Run the Program using FPM (Fortran Package Manager)}

\subparagraph{10 Iterations}

\begin{verbatim}
%%timeit -r 10 -n 1
exec_status = os.system("fpm run - - 10 2>/dev/null > output.txt")
\end{verbatim}

\begin{verbatim}
80.3 ms \pm 26.5 ms per loop (mean \pm std. dev. of 10 runs, 1 loop each)
\end{verbatim}

\begin{verbatim}
%cat output.txt
\end{verbatim}

\begin{verbatim}
After         10 loops, Pi =         3.200000047683716
Actual value of Pi =         3.141592653589793
Absolute difference =         0.058407394093923
\end{verbatim}

\subparagraph{100 Iterations}

\begin{verbatim}
%%timeit -r 10 -n 1
exec_status = os.system("fpm run - - 100 2>/dev/null > output.txt")
\end{verbatim}

\begin{verbatim}
33.5 ms \pm 7.69 ms per loop (mean \pm std. dev. of 10 runs, 1 loop each)
\end{verbatim}

\begin{verbatim}
%cat output.txt
\end{verbatim}

\begin{verbatim}
After        100 loops, Pi =         3.160417031779042
Actual value of Pi =         3.141592653589793
Absolute difference =         0.018824378189249
\end{verbatim}

\subparagraph{1,000 Iterations}

\begin{verbatim}
%%timeit -r 10 -n 1
exec_status = os.system("fpm run - - 1000 2>/dev/null > output.txt")
\end{verbatim}

\begin{verbatim}
32.9 ms \pm 4.03 ms per loop (mean \pm std. dev. of 10 runs, 1 loop each)
\end{verbatim}

\begin{verbatim}
%cat output.txt
\end{verbatim}

\begin{verbatim}
After       1000 loops, Pi =         3.143555466911022
Actual value of Pi =         3.141592653589793
Absolute difference =         0.001962813321229
\end{verbatim}

\subparagraph{10,000 Iterations}

\begin{verbatim}
%%timeit -r 10 -n 1
exec_status = os.system("fpm run - - 10000 2>/dev/null > output.txt")
\end{verbatim}

\begin{verbatim}
31.8 ms \pm 3 ms per loop (mean \pm std. dev. of 10 runs, 1 loop each)
\end{verbatim}

\begin{verbatim}
%cat output.txt
\end{verbatim}

\begin{verbatim}
After      10000 loops, Pi =         3.141791477611602
Actual value of Pi =         3.141592653589793
Absolute difference =         0.000198824021809
\end{verbatim}

\subparagraph{100,000 Iterations}

\begin{verbatim}
%%timeit -r 10 -n 1
exec_status = os.system("fpm run - - 100000 2>/dev/null > output.txt")
\end{verbatim}

\begin{verbatim}
34.4 ms \pm 4.95 ms per loop (mean \pm std. dev. of 10 runs, 1 loop each)
\end{verbatim}

\begin{verbatim}
%cat output.txt
\end{verbatim}

\begin{verbatim}
After     100000 loops, Pi =         3.141612616406209
Actual value of Pi =         3.141592653589793
Absolute difference =         0.000019962816416
\end{verbatim}

\subparagraph{1,000,000 Iterations}

\begin{verbatim}
%%timeit -r 10 -n 1
exec_status = os.system("fpm run - - 1000000 2>/dev/null > output.txt")
\end{verbatim}

\begin{verbatim}
35.9 ms \pm 5.26 ms per loop (mean \pm std. dev. of 10 runs, 1 loop each)
\end{verbatim}

\begin{verbatim}
%cat output.txt
\end{verbatim}

\begin{verbatim}
After    1000000 loops, Pi =         3.141594652402481
Actual value of Pi =         3.141592653589793
Absolute difference =         0.000001998812688
\end{verbatim}

\subparagraph{10,000,000 Iterations}

\begin{verbatim}
%%timeit -r 10 -n 1
exec_status = os.system("fpm run - - 10000000 2>/dev/null > output.txt")
\end{verbatim}

\begin{verbatim}
64.8 ms \pm 7.7 ms per loop (mean \pm std. dev. of 10 runs, 1 loop each)
\end{verbatim}

\begin{verbatim}
%cat output.txt
\end{verbatim}

\begin{verbatim}
After   10000000 loops, Pi =         3.141592854147901
Actual value of Pi =         3.141592653589793
Absolute difference =         0.000000200558108
\end{verbatim}

\subparagraph{100,000,000 Iterations}

\begin{verbatim}
%%timeit -r 10 -n 1
exec_status = os.system("fpm run - - 100000000 2>/dev/null > output.txt")
\end{verbatim}

\begin{verbatim}
274 ms \pm 9.74 ms per loop (mean \pm std. dev. of 10 runs, 1 loop each)
\end{verbatim}

\begin{verbatim}
%cat output.txt
\end{verbatim}

\begin{verbatim}
After  100000000 loops, Pi =         3.141592668260093
Actual value of Pi =         3.141592653589793
Absolute difference =         0.000000014670300
\end{verbatim}

\subparagraph{1,000,000,000 Iterations}

\begin{verbatim}
%%timeit -r 10 -n 1
exec_status = os.system("fpm run - - 1000000000 2>/dev/null > output.txt")
\end{verbatim}

\begin{verbatim}
2.34 s \pm 46.8 ms per loop (mean \pm std. dev. of 10 runs, 1 loop each)
\end{verbatim}

\begin{verbatim}
%cat output.txt
\end{verbatim}

\begin{verbatim}
After 1000000000 loops, Pi =         3.141592665675041
Actual value of Pi =         3.141592653589793
Absolute difference =         0.000000012085248
\end{verbatim}