\begin{verbatim}
- - -
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
 - - -
\end{verbatim}

\subparagraph{Section: BLAS/LAPACK - Vector Copy}

Adapted from: \href{https://github.com/gjbex/Fortran-MOOC/tree/master/source\_code/blas\_lapack}{https://github.com/gjbex/Fortran-MOOC/tree/master/source\_code/blas\_lapack}

\subparagraph{This program demonstrates copying vectors using BLAS/LAPACK in Fortran.}

The Fortran program \texttt{copy\_test} demonstrates the usage of the \texttt{scopy} subroutine, which is typically from the BLAS (Basic Linear Algebra Subprograms) library. The subroutine is used for copying and optionally scaling elements from one vector to another. Here's a step-by-step explanation of what each part of the program does:

\subparagraph{Initialization and Vector Setup}

\begin{enumerate}
\item \textbf{Vector Initialization}:

\begin{itemize}
\item \texttt{vector1} is initialized with the first ten positive real numbers. This is achieved through an array constructor \texttt{[ (real(i), i=1, v\_size) ]}, where \texttt{i} runs from 1 to \texttt{v\_size} (10).
\item \texttt{vector2} is another vector of the same size (\texttt{v\_size}), intended to be the target for copying elements from \texttt{vector1}.
\item \texttt{large\_vector} is a vector twice the size of \texttt{vector1}, used to demonstrate copying with different increments and scaling.
\end{itemize}
\end{enumerate}

\subparagraph{Printing the Original Vector}

\begin{enumerate}[resume]
\item \textbf{Displaying \texttt{vector1}}:

\begin{itemize}
\item The program prints the original content of \texttt{vector1} using a formatted print statement.
\end{itemize}
\end{enumerate}

\subparagraph{Copying Elements with Different Parameters}

\begin{enumerate}[resume]
\item \textbf{First Copy Operation (\texttt{scopy(size(vector1), vector1, 1, vector2, 1)})}:

\begin{itemize}
\item Copies the contents of \texttt{vector1} directly into \texttt{vector2} without any scaling or skipping elements (both source and destination increments are 1). The result is that \texttt{vector2} becomes an exact copy of \texttt{vector1}.
\end{itemize}


\item \textbf{Second Copy Operation (\texttt{scopy(size(vector1), vector1, 1, vector2, 2)})}:

\begin{itemize}
\item Copies elements from \texttt{vector1} into \texttt{vector2} but with a destination increment of 2. This means every second element in \texttt{vector2} is filled, leaving alternate elements as zero (since \texttt{vector2} was reset to 0.0 before this operation).
\end{itemize}


\item \textbf{Third Copy Operation (\texttt{scopy(size(vector1), vector1, 2, vector2, 1)})}:

\begin{itemize}
\item Copies every second element from \texttt{vector1} to \texttt{vector2} with a source increment of 2 and destination increment of 1. This results in \texttt{vector2} containing every second element of \texttt{vector1}, with remaining positions in \texttt{vector2} being zero.
\end{itemize}


\item \textbf{Fourth Copy Operation (\texttt{scopy(size(vector1), vector1, 2, vector2, 2)})}:

\begin{itemize}
\item Both source and destination increments are set to 2, which means every second element from \texttt{vector1} is copied to every second position in \texttt{vector2}.
\end{itemize}
\end{enumerate}

\subparagraph{Demonstrating with a Larger Vector}

\begin{enumerate}[resume]
\item \textbf{Fifth Copy Operation (\texttt{scopy(size(vector1), vector1, 1, large\_vector, 2)})}:

\begin{itemize}
\item Similar to the second copy operation but targets \texttt{large\_vector}. Elements from \texttt{vector1} are placed in every second slot of \texttt{large\_vector}.
\end{itemize}


\item \textbf{Sixth Copy Operation with Scaling (\texttt{scopy(size(vector1), 3.0*vector1, 1, large\_vector(2), 2)})}:

\begin{itemize}
\item This operation is more complex as it involves scaling \texttt{vector1} by 3.0 and copying into \texttt{large\_vector} starting from the second element and skipping every second slot. This demonstrates the ability to combine scaling and non-contiguous memory access in a single operation.
\end{itemize}
\end{enumerate}

\subparagraph{Summary}

The program is a comprehensive demonstration of various capabilities of the \texttt{scopy} subroutine, including element-wise copying with different strides and scaling. Each operation is followed by a print statement to visualize the results of these operations, showcasing how \texttt{scopy} handles different configurations of source and destination vectors. This type of functionality is typically used in numerical and scientific computations where efficient manipulation of large arrays is necessary.

\subparagraph{Program Code}

\begin{verbatim}
program copy_test
  implicit none
  integer, parameter :: v_size = 10
  integer :: i
  real, dimension(v_size) :: vector1 = [ (real(i), i=1, v_size) ], vector2
  real, dimension(2*v_size) :: large_vector

  interface
    subroutine scopy(n, sx, incx, sy, incy)
      integer :: n, incx, incy
      real, dimension(*) :: sx, sy
    end subroutine scopy
  end interface

  print '(A20, *(F5.1))', 'original: ', vector1
  vector2 = 0.0
  large_vector = 0.0
  call scopy(size(vector1), vector1, 1, vector2, 1)
  print '(A20, *(F5.1))', 'copy N 1 1: ', vector2

  vector2 = 0.0
  call scopy(size(vector1), vector1, 1, vector2, 2)
  print '(A20, *(F5.1))', 'copy N 1 2: ', vector2

  vector2 = 0.0
  call scopy(size(vector1), vector1, 2, vector2, 1)
  print '(A20, *(F5.1))', 'copy N 2 1: ', vector2

  vector2 = 0.0
  call scopy(size(vector1), vector1, 2, vector2, 2)
  print '(A20, *(F5.1))', 'copy N 2 2: ', vector2

  large_vector = 0.0
  call scopy(size(vector1), vector1, 1, large_vector, 2)
  print '(A20, *(F5.1))', 'copy N 1 2: ', large_vector
  call scopy(size(vector1), 3.0*vector1, 1, large_vector(2), 2)
  print '(A20, *(F5.1))', 'shift copy N 1 2: ', large_vector

end program copy_test
\end{verbatim}

The above program is compiled and run using Fortran Package Manager (fpm):

\subparagraph{Build the Program using FPM (Fortran Package Manager)}

\begin{verbatim}
import os
root_dir = ""
root_dir = os.getcwd()
\end{verbatim}

Since the code makes use of the LAPACK library, the following FPM configuration file (fpm.toml) was used:

\begin{verbatim}
name = "Section_BLAS_LAPACK_Copy"

[build]
auto -executables = true
auto -tests = true
auto -examples = true
link = ["blas", "lapack"]

[install]
library = false

[[executable]]
name="Section_BLAS_LAPACK_Copy"
source -dir="app"
main="section_blas_lapack_copy.f90"
\end{verbatim}

\begin{verbatim}
code_dir = root_dir + "/" + "Fortran_Code/Section_BLAS_LAPACK_Copy"
\end{verbatim}

\begin{verbatim}
os.chdir(code_dir)
\end{verbatim}

\begin{verbatim}
build_status = os.system("fpm build 2>/dev/null")
\end{verbatim}

\subparagraph{Run the Program using FPM (Fortran Package Manager)}

\begin{verbatim}
exec_status = \
    os.system("fpm run 2>/dev/null")
\end{verbatim}

\begin{verbatim}
original:   1.0  2.0  3.0  4.0  5.0  6.0  7.0  8.0  9.0 10.0
        copy N 1 1:   1.0  2.0  3.0  4.0  5.0  6.0  7.0  8.0  9.0 10.0
        copy N 1 2:   1.0  0.0  2.0  0.0  3.0  0.0  4.0  0.0  5.0  0.0
       copy N 2 1`:   1.0  3.0  5.0  7.0  9.0  0.0  0.0  0.0  0.0  0.0
       copy N 2 2`:   1.0  0.0  3.0  0.0  5.0  0.0  7.0  0.0  9.0  0.0
       copy N 1 2`:   1.0  0.0  2.0  0.0  3.0  0.0  4.0  0.0  5.0  0.0  6.0  0.0  7.0  0.0  8.0  0.0  9.0  0.0 10.0  0.0
 shift copy N 1 2`:   1.0  3.0  2.0  6.0  3.0  9.0  4.0 12.0  5.0 15.0  6.0 18.0  7.0 21.0  8.0 24.0  9.0 27.0 10.0 30.0
\end{verbatim}