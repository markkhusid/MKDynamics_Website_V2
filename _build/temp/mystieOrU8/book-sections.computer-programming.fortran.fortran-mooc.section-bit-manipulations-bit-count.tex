\begin{verbatim}
- - -
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
 - - -
\end{verbatim}

\subparagraph{Section: Bit Manipulations - Bit Count}

Adapted from: \href{https://github.com/gjbex/Fortran-MOOC/tree/master/source\_code/bit\_manipulations}{https://github.com/gjbex/Fortran-MOOC/tree/master/source\_code/bit\_manipulations}

This program demonstrates bit manipulations using Fortran.

\subparagraph{Summary Code Explanation Explanation by ChatGPT 4o}

The given programs and module (\texttt{program bitcount} and \texttt{module bitmanip\_mod}) provide a framework to evaluate and compare multiple methods of counting set bits (1's) in integers. Here's a detailed breakdown of their functionality:


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Program \texttt{bitcount}}}

This is the main driver program that performs the following:

\begin{enumerate}
\item \textbf{Sanity Check}:

\begin{itemize}
\item Iterates over a range of integers from \texttt{-16} to \texttt{16}.
\item For each integer, it calculates the number of set bits using four different methods:

\begin{itemize}
\item \texttt{naive\_count\_bits}
\item \texttt{early\_stopping\_count\_bits}
\item \texttt{lookup\_table\_count\_bits}
\item \texttt{kernighan\_count\_bits}
\end{itemize}


\item Prints the results of these methods alongside the binary representation of the number using the \texttt{bit\_repr} function.
\end{itemize}


\item \textbf{Benchmarking}:

\begin{itemize}
\item Reads the number of values (\texttt{nr\_vals}) from the command line using the subroutine \texttt{get\_arguments}.
\item Allocates an array \texttt{vals} to store random integers for testing.
\item Fills \texttt{vals} with random integers.
\item Times each of the four bit-counting implementations (\texttt{naive}, \texttt{early stopping}, \texttt{lookup table}, and \texttt{Kernighan}) over the generated dataset.
\item Prints the timing results for comparison.
\end{itemize}


\item \textbf{Subroutine \texttt{get\_arguments}}:

\begin{itemize}
\item Validates and extracts the number of integers (\texttt{nr\_vals}) to process from the command-line arguments.
\item Provides error handling if the input is invalid.
\end{itemize}
\end{enumerate}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Module \texttt{bitmanip\_mod}}}

This module contains the bit-counting algorithms, bit representation logic, and utilities for working with a lookup table.

\subparagraph{\textbf{Key Components}:}

\begin{enumerate}
\item \textbf{Lookup Table Management}:

\begin{itemize}
\item A 256-element lookup table (\texttt{lookup\_table}) is used to optimize bit-counting for bytes (8-bit chunks).
\item The \texttt{ensure\_lookup\_table\_initialized} subroutine ensures the table is loaded from a CSV file before use.
\item \texttt{initialize\_lookup\_table} reads values from \texttt{lookup\_table.dat} using a CSV reader (\texttt{csv\_module}).
\end{itemize}


\item \textbf{Utility Functions}:

\begin{itemize}
\item \texttt{bit\_repr}: Converts an integer into its binary string representation.
\item \texttt{remove\_trailing\_comma\_ampersand}: Cleans up lines from the CSV file by removing trailing \texttt{, \&} for compatibility.
\end{itemize}


\item \textbf{Bit-Counting Methods}:

\begin{itemize}
\item \textbf{\texttt{naive\_count\_bits}}:

\begin{itemize}
\item Counts bits by iteratively checking the least significant bit using \texttt{and(n, 1)} and shifting the number (\texttt{ishft}).
\item Iterates a fixed number of times (32 for 32-bit integers).
\end{itemize}


\item \textbf{\texttt{early\_stopping\_count\_bits}}:

\begin{itemize}
\item Similar to \texttt{naive\_count\_bits}, but exits early when all remaining bits are 0.
\end{itemize}


\item \textbf{\texttt{lookup\_table\_count\_bits}}:

\begin{itemize}
\item Divides the integer into four 8-bit chunks.
\item Uses the lookup table to sum the number of set bits in each chunk.
\item This is faster because it avoids iterative bit operations.
\end{itemize}


\item \textbf{\texttt{kernighan\_count\_bits}}:

\begin{itemize}
\item Uses Brian Kernighan's algorithm, which repeatedly clears the least significant set bit (\texttt{n = and(n, n - 1)}) until the number becomes 0.
\item The number of iterations equals the number of set bits.
\end{itemize}
\end{itemize}


\item \textbf{CSV File Parsing}:

\begin{itemize}
\item \texttt{parse\_csv\_file}: Reads a CSV file, preprocesses it to remove trailing artifacts, and populates the lookup table.
\item Uses the \texttt{csv\_module} library for handling CSV data.
\end{itemize}
\end{enumerate}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Workflow}}

\begin{enumerate}
\item \textbf{Sanity Check}:

\begin{itemize}
\item Validates that all methods produce the same results for small integers (-16 to 16).
\end{itemize}


\item \textbf{Benchmarking}:

\begin{itemize}
\item Tests the efficiency of each method over a large dataset of random integers, highlighting performance differences.
\end{itemize}


\item \textbf{Bit Manipulation Techniques}:

\begin{itemize}
\item Each method showcases different trade-offs between simplicity, performance, and implementation complexity:

\begin{itemize}
\item Naive: Simple but slow.
\item Early Stopping: Optimized for sparse integers with fewer set bits.
\item Lookup Table: Fast for large datasets, relies on preprocessing and memory.
\item Kernighan: Efficient in terms of operations for sparse integers.
\end{itemize}
\end{itemize}


\item \textbf{Results}:

\begin{itemize}
\item Binary representations and bit counts are printed for verification.
\item Execution times are reported for performance analysis.
\end{itemize}
\end{enumerate}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Key Features and Highlights}}

\begin{itemize}
\item \textbf{Modular Design}: The \texttt{bitmanip\_mod} encapsulates reusable logic, making the implementation extendable and maintainable.
\item \textbf{Error Handling}: Comprehensive checks for memory allocation, file reading, and input validity.
\item \textbf{Performance Comparison}: Benchmarks allow empirical evaluation of different approaches, useful for understanding their practical efficiency.
\item \textbf{Lookup Table Preprocessing}: Demonstrates efficient preprocessing for rapid bit-counting.
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{\textbf{Applications}}

This program can be used to:

\begin{itemize}
\item Analyze and optimize bitwise operations in software.
\item Serve as a teaching tool for bit manipulation techniques.
\item Benchmark and compare algorithmic performance for counting set bits.
\end{itemize}

\subparagraph{Detailed Analysis by ChatGPT 4o1: \texttt{bitcount.f90}}

Below is an extremely detailed, section-by-section analysis of \textbf{\texttt{bitcount.f90}}, which serves as a driver program to demonstrate and benchmark various bit-counting methods defined in the companion module \textbf{\texttt{bitmanip\_mod}}. We'll examine the program's flow, purpose of each block of code, and some considerations for performance and design.


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{1. \textbf{Program Declaration and Imports}}

\begin{verbatim}
program bitcount
    use, intrinsic :: iso_fortran_env, only : error_unit
    use :: bitmanip_mod
    implicit none
\end{verbatim}

\begin{enumerate}
\item \textbf{\texttt{program bitcount}}: Declares the main program unit named \texttt{bitcount}.
\item \textbf{\texttt{use, intrinsic :: iso\_fortran\_env, only : error\_unit}}:

\begin{itemize}
\item Imports \texttt{error\_unit}, a predefined I/O unit for error reporting from the Fortran intrinsic module \texttt{iso\_fortran\_env}.
\item \texttt{error\_unit} is commonly used in lieu of a hard-coded unit number (e.g., 0 or 2) for consistent error output.
\end{itemize}


\item \textbf{\texttt{use :: bitmanip\_mod}}:

\begin{itemize}
\item Brings in public symbols from the \texttt{bitmanip\_mod} module. This includes the following procedures:

\begin{itemize}
\item \texttt{naive\_count\_bits}
\item \texttt{early\_stopping\_count\_bits}
\item \texttt{lookup\_table\_count\_bits}
\item \texttt{kernighan\_count\_bits}
\item \texttt{bit\_repr}
\end{itemize}


\item The \texttt{bitmanip\_mod} also automatically handles initialization of its lookup table for the lookup-table-based bit-counting method.
\end{itemize}


\item \textbf{\texttt{implicit none}}:

\begin{itemize}
\item Prohibits the use of implicitly typed variables, requiring all variables to be declared explicitly.
\item Improves safety by preventing accidental usage of undeclared variables.
\end{itemize}
\end{enumerate}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{2. \textbf{Variable Declarations}}

\begin{verbatim}
integer :: nr_vals
    integer(kind=I4), dimension(:), allocatable :: vals
    integer(kind=I4) :: result
    integer :: i, istat
    integer :: naive_count_bits_result, early_stopping_count_bits_result, &
        lookup_table_count_bits_result, kernighan_count_bits_result
    real :: r, start_time, end_time
\end{verbatim}

\begin{enumerate}
\item \textbf{\texttt{nr\_vals}}: Holds the number of values (integers) to be processed, as read from the command-line argument.
\item \textbf{\texttt{vals}} (\texttt{integer(kind=I4), dimension(:), allocatable}):

\begin{itemize}
\item An allocatable array that will store \texttt{nr\_vals} random integers (\texttt{kind=I4} is a 32-bit integer type).
\end{itemize}


\item \textbf{\texttt{result}} (\texttt{integer(kind=I4)}):

\begin{itemize}
\item Will store the cumulative result (via XOR) during benchmarks of the bit-counting routines.
\end{itemize}


\item \textbf{\texttt{i, istat}} (\texttt{integer}):

\begin{itemize}
\item \texttt{i} is a loop counter.
\item \texttt{istat} captures the status code returned by array allocation.
\end{itemize}


\item \textbf{\texttt{naive\_count\_bits\_result, early\_stopping\_count\_bits\_result,}\newline
\texttt{lookup\_table\_count\_bits\_result, kernighan\_count\_bits\_result}}:

\begin{itemize}
\item Temporary integers to hold the results from each of the four bit-counting methods for a given integer in the sanity check loop.
\end{itemize}


\item \textbf{\texttt{r, start\_time, end\_time}} (\texttt{real}):

\begin{itemize}
\item \texttt{r}: used to store random numbers in the range [0,1).
\item \texttt{start\_time, end\_time}: used with \texttt{cpu\_time} intrinsic to measure benchmarking durations.
\end{itemize}
\end{enumerate}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{3. \textbf{Sanity Check Loop}}

\begin{verbatim}
print '(A)', 'sanity check: naive, early stopping, lookup table Kernighan'
    do i = -16, 16
        naive_count_bits_result = naive_count_bits(i)
        early_stopping_count_bits_result = early_stopping_count_bits(i)
        lookup_table_count_bits_result = lookup_table_count_bits(i)
        kernighan_count_bits_result = kernighan_count_bits(i)

        print '(I14, 3A, 4I3)', i, ': ', bit_repr(i), ': ', &
            naive_count_bits_result, early_stopping_count_bits_result, &
            lookup_table_count_bits_result, kernighan_count_bits_result
    end do
\end{verbatim}

\begin{enumerate}
\item \textbf{Purpose}:

\begin{itemize}
\item Verifies that all four bit-counting functions (\texttt{naive\_count\_bits}, \texttt{early\_stopping\_count\_bits}, \texttt{lookup\_table\_count\_bits}, \texttt{kernighan\_count\_bits}) produce the same result for a range of integers from \texttt{-16} to \texttt{16}.
\end{itemize}


\item \textbf{Details}:

\begin{itemize}
\item Prints a header line: \texttt{"sanity check: naive, early stopping, lookup table Kernighan"}.
\item Iterates \texttt{i} from \texttt{-16} up to \texttt{16}.
\item For each integer \texttt{i}, obtains its bit counts via each method and also retrieves its binary representation via \texttt{bit\_repr(i)}.
\item Prints the integer, its binary representation, and the four counts.
\item Note the format string \texttt{'(I14, 3A, 4I3)'}:

\begin{itemize}
\item \texttt{I14}: prints the integer \texttt{i} in a field of 14 characters (right-aligned).
\item \texttt{3A}: prints three consecutive strings (in this case, \texttt{": "}, \texttt{bit\_repr(i)}, and \texttt{": "}).
\item \texttt{4I3}: prints the four integer results in fields of width 3 each.
\end{itemize}
\end{itemize}


\item \textbf{Significance}:

\begin{itemize}
\item This ``sanity check'' ensures the correctness of the implementations on both positive and negative values (showing how negative values are handled, presumably via two's complement representation).
\end{itemize}
\end{enumerate}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{4. \textbf{Creating Values for Benchmarking}}

\subparagraph{4.1 \textbf{Reading Command-Line Argument}}

\begin{verbatim}
call get_arguments(nr_vals)
\end{verbatim}

\begin{itemize}
\item Calls a local subroutine \texttt{get\_arguments} (defined in the \texttt{contains} section at the end of the program) which:

\begin{itemize}
\item Ensures exactly one command-line argument is present.
\item Reads it into \texttt{nr\_vals}.
\item Exits with an error if invalid input is provided.
\end{itemize}
\end{itemize}

\subparagraph{4.2 \textbf{Allocating the Array}}

\begin{verbatim}
allocate (vals(nr_vals), stat=istat)
    if (istat /= 0) then
        write (unit=error_unit, fmt='(A, I0, A)') 'error: can not allocate ', &
            nr_vals, ' elements'
        stop 3
    end if
\end{verbatim}

\begin{enumerate}
\item \textbf{Tries} to allocate the array \texttt{vals} of length \texttt{nr\_vals}.
\item \textbf{Checks} if \texttt{istat} (the status code from the allocation) is not zero, meaning an allocation failure:

\begin{itemize}
\item If failed, writes an error message to \texttt{error\_unit} with \texttt{'error: can not allocate X elements'}.
\item Terminates the program with exit code 3.
\end{itemize}
\end{enumerate}

\subparagraph{4.3 \textbf{Filling \texttt{vals} with Random Integers}}

\begin{verbatim}
do i = 1, size(vals)
        call random_number(r)
        vals(i) = int(r*real(huge(0_I4)), kind=I4)
    end do
\end{verbatim}

\begin{enumerate}
\item \textbf{Generates} a random real number \texttt{r} in \texttt{[0,1)} via \texttt{call random\_number(r)}.
\item \textbf{Scales} it to the range \texttt{[0, huge(0\_I4)]}---the largest representable 32-bit integer---by multiplying by \texttt{r}.
\item \textbf{Converts} to a 32-bit integer via \texttt{int(..., kind=I4)}.
\item \textbf{Stores} the result in \texttt{vals(i)}.
\item \textbf{Goal}: Populate a large array of random 32-bit integers for performance testing.
\end{enumerate}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{5. \textbf{Benchmarking Loops}}

The program times each bit-counting method by:

\begin{enumerate}
\item Recording a start time.
\item Looping over all values in \texttt{vals}, applying the bit-counting method, and XOR-ing results into \texttt{result}.
\item Recording an end time.
\item Computing \texttt{end\_time - start\_time} to measure the method's total execution time.
\end{enumerate}

The XOR (\texttt{result = xor(result, ...)}) is presumably done to prevent the compiler from optimizing away the function calls in a trivial scenario; storing or mixing results ensures each bit-counting call cannot be elided.

\subparagraph{5.1 \textbf{Naive Implementation}}

\begin{verbatim}
call cpu_time(start_time)
    do i = 1, size(vals)
        result = xor(result, naive_count_bits(vals(i)))
    end do
    call cpu_time(end_time)
    print '(A, I0, A, F15.6)', 'naive implementation ', size(vals), &
        ' iterations: ', end_time - start_time
\end{verbatim}

\begin{enumerate}
\item \textbf{\texttt{cpu\_time}}:

\begin{itemize}
\item Built-in Fortran intrinsic that returns a process-based CPU time in seconds (implementation-dependent).
\item Captures \texttt{start\_time} before the loop, \texttt{end\_time} after the loop.
\end{itemize}


\item \textbf{Loop}:

\begin{itemize}
\item Iterates over the entire \texttt{vals} array.
\item Calls \texttt{naive\_count\_bits(vals(i))}.
\item XORs the returned bit count with the accumulating \texttt{result}.
\end{itemize}


\item \textbf{Prints}: The method name, the number of iterations (\texttt{size(vals)}), and the total execution time formatted in \texttt{F15.6} (15 wide, 6 decimal places).
\end{enumerate}

\subparagraph{5.2 \textbf{Early Stopping Implementation}}

\begin{verbatim}
call cpu_time(start_time)
    do i = 1, size(vals)
        result = xor(result, early_stopping_count_bits(vals(i)))
    end do
    call cpu_time(end_time)
    print '(A, I0, A, F15.6)', 'early stopping implementation ', size(vals), &
        ' iterations: ', end_time - start_time
\end{verbatim}

\begin{itemize}
\item Same structure as above, but uses \texttt{early\_stopping\_count\_bits}.
\end{itemize}

\subparagraph{5.3 \textbf{Lookup Table Implementation}}

\begin{verbatim}
call cpu_time(start_time)
    do i = 1, size(vals)
        result = xor(result, lookup_table_count_bits(vals(i)))
    end do
    call cpu_time(end_time)
    print '(A, I0, A, F15.6)', 'lookup table implementation ', size(vals), &
        ' iterations: ', end_time - start_time
\end{verbatim}

\begin{itemize}
\item Same benchmarking pattern, but with \texttt{lookup\_table\_count\_bits}.
\end{itemize}

\subparagraph{5.4 \textbf{Kernighan's Implementation}}

\begin{verbatim}
call cpu_time(start_time)
    do i = 1, size(vals)
        result = xor(result, kernighan_count_bits(vals(i)))
    end do
    call cpu_time(end_time)
    print '(A, I0, A, F15.6)', 'Kernighan implementation ', size(vals), &
        ' iterations: ', end_time - start_time
\end{verbatim}

\begin{itemize}
\item Same pattern using \texttt{kernighan\_count\_bits}.
\end{itemize}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{6. \textbf{Contained Subroutine: \texttt{get\_arguments}}}

At the end of the file, after the main executable sections, the program uses an internal subroutine to handle command-line arguments.

\begin{verbatim}
contains

    subroutine get_arguments(nr_vals)
        use, intrinsic :: iso_fortran_env, only : error_unit
        implicit none
        integer, intent(out) :: nr_vals
        character(len=1024) :: buffer, msg
        integer :: istat

        if (command_argument_count() /= 1) then
            write (unit=error_unit, fmt='(A)') 'error: expecting number of values'
            write (unit=*, fmt='(A)') 'error: expecting number of values'
            stop 1
        end if
        call get_command_argument(1, buffer)
        read (buffer, fmt=*, iostat=istat, iomsg=msg) nr_vals
        if (istat /= 0) then
            write (unit=error_unit, fmt='(2A)') 'error: ', trim(msg)
            stop 2
        end if
    end subroutine get_arguments

end program bitcount
\end{verbatim}

\begin{enumerate}
\item \textbf{\texttt{contains}}:

\begin{itemize}
\item A special block in Fortran programs or modules that holds internal procedures.
\end{itemize}


\item \textbf{\texttt{subroutine get\_arguments(nr\_vals)}}:

\begin{itemize}
\item \textbf{Purpose}: Reads exactly one command-line argument (the expected integer \texttt{nr\_vals}).
\item \textbf{Behavior}:

\begin{itemize}
\item Checks if \texttt{command\_argument\_count()} (the number of command-line arguments) is exactly 1; if not, writes an error to \texttt{error\_unit} and stops with code \texttt{1}.
\item Extracts the argument string into \texttt{buffer} via \texttt{get\_command\_argument(1, buffer)}.
\item Attempts to parse \texttt{buffer} as an integer into \texttt{nr\_vals} using an unformatted read.

\begin{itemize}
\item If \texttt{istat /= 0}, meaning a read error or type mismatch, prints an error with the \texttt{iomsg} and stops with code \texttt{2}.
\end{itemize}
\end{itemize}
\end{itemize}


\item \textbf{Note}:

\begin{itemize}
\item This approach is typical in Fortran to parse arguments from the command line (when compiled for systems that support it, which is most modern Fortran compilers).
\end{itemize}
\end{enumerate}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{7. \textbf{High-Level Flow Summary}}

Putting it all together:

\begin{enumerate}
\item \textbf{Initialization}:

\begin{itemize}
\item The program starts and immediately imports the bit manipulation module (\texttt{bitmanip\_mod}).
\item No explicit module initialization is called here; however, if the user calls a bit-counting method that requires the lookup table, \texttt{bitmanip\_mod} takes care of loading it on first use.
\end{itemize}


\item \textbf{Sanity Check}:

\begin{itemize}
\item The program iterates from -16 to 16, computing bit counts via each of the four methods.
\item Prints the integer, its binary form, and the counts. This confirms correctness and demonstrates consistency among methods for small positive/negative integers.
\end{itemize}


\item \textbf{Command-Line Argument}:

\begin{itemize}
\item Reads \texttt{nr\_vals}, ensuring the user provided one argument (the number of random values to test).
\end{itemize}


\item \textbf{Allocate \& Populate Data}:

\begin{itemize}
\item Dynamically allocates an array of 32-bit integers.
\item Fills it with random values spanning the possible integer range.
\end{itemize}


\item \textbf{Benchmarking}:

\begin{itemize}
\item For each of the four methods:

\begin{enumerate}
\item Record start time via \texttt{cpu\_time}.
\item Loop over \texttt{vals}, compute bit count, XOR with \texttt{result}.
\item Record end time.
\item Print elapsed time.
\end{enumerate}
\end{itemize}


\item \textbf{Exit}:

\begin{itemize}
\item After printing all four benchmarks, the program ends.
\end{itemize}
\end{enumerate}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{8. \textbf{Notable Considerations}}

\begin{enumerate}
\item \textbf{Negative vs. Positive Values}:

\begin{itemize}
\item The sanity check covers negative values. The bit-counting routines will handle them correctly assuming two's complement. The \texttt{bit\_repr} function in \texttt{bitmanip\_mod} displays the internal binary representation, including sign bits for negative numbers.
\end{itemize}


\item \textbf{Performance}:

\begin{itemize}
\item The four approaches (Naive, Early Stopping, Lookup Table, Kernighan) have different performance characteristics. The program's timing output shows which approach is fastest for a given number of iterations.
\end{itemize}


\item \textbf{\texttt{result} XOR}:

\begin{itemize}
\item The \texttt{result = xor(result, ...)} line ensures that the function call is not optimized away. If the loop simply called \texttt{naive\_count\_bits(vals(i))} without using the result, a compiler might skip or inline it, artificially boosting performance.
\item The XOR ensures a dependency on the returned value, making the measurement more realistic.
\end{itemize}


\item \textbf{Scalability}:

\begin{itemize}
\item The user can pass large \texttt{nr\_vals} to create a substantial workload, thus measuring and comparing the methods over many iterations.
\end{itemize}


\item \textbf{Error Handling}:

\begin{itemize}
\item The program uses \texttt{stop} statements with nonzero codes for various error conditions:

\begin{itemize}
\item \texttt{1}: Wrong number of command-line arguments.
\item \texttt{2}: Failed to parse integer from the command line.
\item \texttt{3}: Failure in memory allocation.
\end{itemize}


\item Messages are written to \texttt{error\_unit} to help diagnose problems.
\end{itemize}
\end{enumerate}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{9. \textbf{Conclusion}}

\textbf{\texttt{bitcount.f90}} is a concise yet powerful driver program that:

\begin{itemize}
\item Demonstrates correctness for multiple bit-counting algorithms (\texttt{naive}, \texttt{early stopping}, \texttt{lookup table}, \texttt{Kernighan}).
\item Benchmarks each method across a user-specified number of randomly generated 32-bit integers.
\item Leverages the companion module \texttt{bitmanip\_mod} for all bitwise utilities and the lookup-table feature.
\end{itemize}

This design makes it easy to compare performance, study different approaches to counting bits, and serve as a template for further exploration of bitwise operations in Fortran.

\subparagraph{Detailed Analysis by ChatGPT 4o1: \texttt{bitmanip\_mod}}

Below is a comprehensive, section-by-section analysis of the Fortran module \textbf{\texttt{bitmanip\_mod}}. This module contains bit-counting routines, a mechanism for loading a 256-element lookup table from a CSV file, and several utility routines for string manipulation and bitwise operations. It demonstrates careful management of initialization, file I/O, and the use of public/private scope to organize code effectively.


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{1. \textbf{Module Declaration}}

\begin{verbatim}
module bitmanip_mod
    use, intrinsic :: iso_fortran_env, only : INT32, error_unit
    use csv_module

    implicit none

    private
\end{verbatim}

\begin{enumerate}
\item \texttt{module bitmanip\_mod}: Defines a Fortran module named \texttt{bitmanip\_mod}.
\item \textbf{\texttt{use, intrinsic :: iso\_fortran\_env, only : INT32, error\_unit}}:

\begin{itemize}
\item \texttt{INT32} is an integer kind parameter guaranteeing a 32-bit integer (as per the ISO Fortran environment).
\item \texttt{error\_unit} is a special I/O unit typically used for error reporting.
\end{itemize}


\item \textbf{\texttt{use csv\_module}}: Imports a third-party or external library providing CSV-related capabilities (presumably the ``csv-fortran'' library or similar).
\item \textbf{\texttt{implicit none}}: Disallows implicit typing of variables, ensuring safer and more explicit code.
\item \textbf{\texttt{private}}: Sets the default accessibility of module entities to private, making them inaccessible to other program units unless explicitly declared \texttt{public}.
\end{enumerate}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{2. \textbf{Lookup Table and Flags}}

\begin{verbatim}
! A 256 -element lookup table stored in the module
    integer, public, parameter :: I4 = INT32
    integer(kind=I4), dimension(0:255), private :: lookup_table
    logical, private, save :: initialized = .false.
\end{verbatim}

\begin{enumerate}
\item \texttt{integer, public, parameter :: I4 = INT32}

\begin{itemize}
\item Defines a module parameter \texttt{I4} that is publicly visible.
\item \texttt{I4} is set to \texttt{INT32}, effectively binding the symbol \texttt{I4} to the 32-bit integer kind. Other routines use \texttt{I4} to ensure consistent integer typing.
\end{itemize}


\item \texttt{integer(kind=I4), dimension(0:255), private :: lookup\_table}

\begin{itemize}
\item Declares an array \texttt{lookup\_table} of size 256 (\texttt{indices 0 to 255}) to store precomputed bit counts or other associated values.
\item Marked \texttt{private}, so it cannot be accessed directly from outside the module.
\end{itemize}


\item \texttt{logical, private, save :: initialized = .false.}

\begin{itemize}
\item A logical flag indicating whether the lookup table has already been loaded from disk.
\item Marked \texttt{save} so that its state persists across multiple calls; otherwise, it might not retain its value.
\end{itemize}
\end{enumerate}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{3. \textbf{Public Interfaces}}

\begin{verbatim}
! Public procedures
    public :: naive_count_bits, early_stopping_count_bits, bit_repr, &
              lookup_table_count_bits, kernighan_count_bits
\end{verbatim}

\begin{itemize}
\item Declares which routines in the module are accessible externally:

\begin{enumerate}
\item \texttt{naive\_count\_bits}
\item \texttt{early\_stopping\_count\_bits}
\item \texttt{bit\_repr}
\item \texttt{lookup\_table\_count\_bits}
\item \texttt{kernighan\_count\_bits}
\end{enumerate}
\end{itemize}

Everything else in the module remains \texttt{private}, reinforcing modular encapsulation.


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{4. \textbf{Subroutines for Lookup Table Initialization}}

\subparagraph{4.1 \textbf{\texttt{ensure\_lookup\_table\_initialized}}}

\begin{verbatim}
subroutine ensure_lookup_table_initialized()
    if (.not. initialized) then
        call initialize_lookup_table()
    end if
end subroutine ensure_lookup_table_initialized
\end{verbatim}

\begin{itemize}
\item \textbf{Purpose}: Checks the \texttt{initialized} flag. If the lookup table is not yet loaded, it calls \texttt{initialize\_lookup\_table}.
\item \textbf{Key Detail}: Ensures that the following bit-counting routines, which depend on the lookup table, do not proceed until the table is valid and loaded.
\end{itemize}

\subparagraph{4.2 \textbf{\texttt{initialize\_lookup\_table}}}

\begin{verbatim}
subroutine initialize_lookup_table()
    implicit none
    integer :: ios

    ! Clear the module array
    lookup_table = 0

    ! Call parse_csv_file to fill the local array
    call parse_csv_file("lookup_table.dat", lookup_table, ios)

    if (ios == 0) then
        initialized = .true.
    else
        write(error_unit, '(A,I0)') "Failed to read CSV lookup table, ios=", ios
        stop 1
    end if
end subroutine initialize_lookup_table
\end{verbatim}

\begin{enumerate}
\item \textbf{Clears} the \texttt{lookup\_table} array by setting all elements to zero initially.
\item \textbf{Calls} \texttt{parse\_csv\_file("lookup\_table.dat", lookup\_table, ios)}:

\begin{itemize}
\item Attempts to load the data from \texttt{lookup\_table.dat} into \texttt{lookup\_table}.
\item \texttt{ios} serves as an error code to indicate success or failure.
\end{itemize}


\item \textbf{Sets} \texttt{initialized = .true.} if \texttt{ios == 0}, indicating successful initialization.
\item \textbf{Stops execution} if there is a failure (non-zero \texttt{ios}), printing an error message to \texttt{error\_unit}.
\end{enumerate}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{5. \textbf{CSV File Parsing: \texttt{parse\_csv\_file}}}

\begin{verbatim}
subroutine parse_csv_file(filename, table_data, ios)
    use csv_module
    
    implicit none

    ! Subroutine arguments
    character(len=*), intent(in)                                :: filename
    integer(kind=I4), dimension(0:255), intent(out)             :: table_data
    integer, intent(out)                                        :: ios

    ...
end subroutine parse_csv_file
\end{verbatim}

\begin{itemize}
\item \textbf{Purpose}: Reads a CSV file \texttt{filename}, processes it, and populates \texttt{table\_data} (the 256-element integer array).
\item \textbf{Arguments}:

\begin{enumerate}
\item \texttt{filename}: Name of the CSV file to read.
\item \texttt{table\_data}: The 256-element array to store the parsed data.
\item \texttt{ios}: Output integer error code to capture success/failure.
\end{enumerate}
\end{itemize}

\subparagraph{5.1 \textbf{Local Variables}}

\begin{verbatim}
type(csv_file)                :: c
logical                       :: status_ok
character(len=255), allocatable, dimension(:,:) :: string_table
integer                       :: nrow, ncol
integer                       :: i, j, idx, ios2, val
character(len=30)             :: trimmed_string

! For pre -processing:
integer                       :: unit_in, unit_out, status_in, status_out
character(len=1024)           :: line, tmpfile
logical                       :: done
\end{verbatim}

\begin{itemize}
\item \textbf{\texttt{c}}: An instance of \texttt{csv\_file} from \texttt{csv\_module}.
\item \textbf{\texttt{string\_table}}: A 2D array of strings holding the CSV data read by \texttt{csv\_module}.
\item \textbf{\texttt{nrow}, \texttt{ncol}}: Dimensions of the CSV data.
\item \textbf{\texttt{idx}}: Tracks how many entries have been written to \texttt{table\_data}.
\item \textbf{\texttt{trimmed\_string}}: Used to trim whitespace or extraneous characters before numeric conversion.
\item \textbf{\texttt{unit\_in}, \texttt{unit\_out}}: File unit numbers for reading from the input CSV and writing to a temporary file.
\item \textbf{\texttt{line}}, \textbf{\texttt{tmpfile}}: Buffers for file I/O; \texttt{tmpfile} is the name of the temporary file to generate.
\item \textbf{\texttt{done}}: A loop control flag (typical for reading files until EOF).
\end{itemize}

\subparagraph{5.2 \textbf{Preprocessing Logic}}

\begin{verbatim}
tmpfile = 'tempfile.csv'
open(newunit=unit_in, file=filename, status='old', action='read', &
     form='formatted', iostat=status_in)
\end{verbatim}

\begin{enumerate}
\item \textbf{Opens} the \texttt{filename} for reading on unit \texttt{unit\_in}.
\item \textbf{Creates} a new file \texttt{tempfile.csv} on unit \texttt{unit\_out} with \texttt{status='replace'}.
\item \textbf{Reads} each line from the original file, calls \texttt{remove\_trailing\_comma\_ampersand} to clean trailing \texttt{, \&}, then writes the cleaned line to \texttt{tempfile.csv}.
\end{enumerate}

This approach ensures that any extraneous trailing commas or ampersands in the original file (e.g., lines ending with \texttt{, \&}) are removed before CSV parsing.

\subparagraph{5.3 \textbf{CSV Parsing Using \texttt{csv\_module}}}

\begin{verbatim}
call c%initialize()
call c%read(tmpfile, status_ok=status_ok)
call c%get(string_table, status_ok=status_ok)
\end{verbatim}

\begin{enumerate}
\item \textbf{Initialize} the \texttt{csv\_file} object.
\item \textbf{Read} the temporary file \texttt{tmpfile.csv}, storing its contents in an internal buffer.
\item \textbf{Get} the data as a 2D string array \texttt{string\_table}.
\end{enumerate}

\subparagraph{5.4 \textbf{Populating \texttt{table\_data}}}

\begin{verbatim}
nrow = size(string_table,1)
ncol = size(string_table,2)

idx = 0
do i = 1, nrow
    do j = 1, ncol
        trimmed_string = adjustl(adjustl(string_table(i,j)))
        read(trimmed_string, *) val
        table_data(idx) = val
        idx = idx + 1
    end do
end do
\end{verbatim}

\begin{enumerate}
\item Determines the dimensions (\texttt{nrow}, \texttt{ncol}) of the string data.
\item Iterates over all cells, trimming whitespace.
\item \textbf{Reads} each cell into an integer \texttt{val}.
\item Assigns \texttt{val} to \texttt{table\_data(idx)} and increments \texttt{idx}.
\item Since \texttt{table\_data} is only 256 elements, this routine assumes at most 256 integer values are needed.
\end{enumerate}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{6. \textbf{String Cleanup Subroutine: \texttt{remove\_trailing\_comma\_ampersand}}}

\begin{verbatim}
subroutine remove_trailing_comma_ampersand(line)
    implicit none
    character(len=*), intent(inout) :: line
    integer :: n
    
    n = len_trim(line)
    ...
end subroutine remove_trailing_comma_ampersand
\end{verbatim}

\begin{itemize}
\item \textbf{Purpose}: Removes trailing \texttt{\&} and \texttt{, } from a line. This addresses cases like:

\begin{verbatim}
42, &
\end{verbatim}

which should become simply

\begin{verbatim}
42
\end{verbatim}


\item \textbf{Implementation}:

\begin{enumerate}
\item Find the trimmed length \texttt{n = len\_trim(line)}.
\item While the last character is \texttt{'\&'}, remove it.
\item Then check if the last two characters are \texttt{", "}, remove them as well.
\end{enumerate}
\end{itemize}

This makes the file lines more compatible with standard CSV parsing.


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{7. \textbf{Bit-Counting Routines}}

Each of these functions is declared \texttt{public} and returns an integer bit count or a string representation (in the case of \texttt{bit\_repr}). They all call \texttt{ensure\_lookup\_table\_initialized()} first, although for certain algorithms (like naive or Kernighan), the lookup table is not strictly needed. This ensures consistency and that the module's data is ready.

\subparagraph{7.1 \textbf{\texttt{naive\_count\_bits(n) result(bit\_count)}}}

\begin{verbatim}
function naive_count_bits(n) result(bit_count)
    integer(kind=I4), value :: n
    integer :: bit_count
    integer :: i

    call ensure_lookup_table_initialized()

    bit_count = 0
    do i = 1, 32
        bit_count = bit_count + and(n, 1_I4)
        n = ishft(n, -1)
    end do
end function naive_count_bits
\end{verbatim}

\begin{enumerate}
\item \textbf{Parameters}:

\begin{itemize}
\item \texttt{n}: a 32-bit integer (kind=I4), passed by value.
\item \texttt{bit\_count}: the returned result (total number of 1 bits).
\end{itemize}


\item \textbf{Logic}:

\begin{itemize}
\item Loops exactly 32 times for a 32-bit integer.
\item Checks the least significant bit \texttt{and(n, 1\_I4)}.
\item Accumulates the bit count.
\item Shifts \texttt{n} right by 1 each iteration.
\end{itemize}


\item \textbf{Performance}: Straightforward but not the most efficient.
\end{enumerate}

\subparagraph{7.2 \textbf{\texttt{early\_stopping\_count\_bits(n) result(bit\_count)}}}

\begin{verbatim}
function early_stopping_count_bits(n) result(bit_count)
    integer(kind=I4), value :: n
    integer :: bit_count
    integer :: i

    call ensure_lookup_table_initialized()

    bit_count = 0
    do i = 1, 32
        bit_count = bit_count + and(n, 1_I4)
        n = ishft(n, -1)
        if (n == 0) exit
    end do
end function early_stopping_count_bits
\end{verbatim}

\begin{enumerate}
\item \textbf{Difference from Naive}:

\begin{itemize}
\item After shifting, if \texttt{n} becomes 0, it exits early. This optimization helps when \texttt{n} is small or has bits set early in the lower portion.
\end{itemize}


\item \textbf{Performance}: Faster for numbers with few high-order bits set, as it avoids unnecessary loop iterations.
\end{enumerate}

\subparagraph{7.3 \textbf{\texttt{lookup\_table\_count\_bits(n) result(bit\_count)}}}

\begin{verbatim}
function lookup_table_count_bits(n) result(bit_count)
    integer(kind=I4), value :: n
    integer :: bit_count

    call ensure_lookup_table_initialized()

    bit_count = lookup_table(and(n, 255_I4)) + &
                lookup_table(and(ishft(n, -8), 255_I4)) + &
                lookup_table(and(ishft(n, -16), 255_I4)) + &
                lookup_table(and(ishft(n, -24), 255_I4))
end function lookup_table_count_bits
\end{verbatim}

\begin{enumerate}
\item \textbf{Approach}:

\begin{itemize}
\item Splits the 32-bit integer \texttt{n} into four 8-bit segments using right shifts and masks:

\begin{itemize}
\item The lowest 8 bits: \texttt{and(n, 255\_I4)}
\item The next 8 bits: \texttt{and(ishft(n, -8), 255\_I4)}
\item And so forth up to 24 bits.
\end{itemize}
\end{itemize}


\item \textbf{Lookup}:

\begin{itemize}
\item Each 8-bit value serves as an index into \texttt{lookup\_table}, which presumably stores the number of set bits for all numbers from 0 to 255.
\item Summing these four partial counts yields the total set bits in 32 bits.
\end{itemize}


\item \textbf{Performance}:

\begin{itemize}
\item Very efficient, since each 8-bit chunk's bit count is retrieved in O(1) time.
\item Requires memory for the table and a one-time file read to initialize.
\end{itemize}
\end{enumerate}

\subparagraph{7.4 \textbf{\texttt{kernighan\_count\_bits(n) result(bit\_count)}}}

\begin{verbatim}
function kernighan_count_bits(n) result(bit_count)
    integer(kind=I4), value :: n
    integer :: bit_count

    call ensure_lookup_table_initialized()

    bit_count = 0
    do while (n /= 0)
        n = and(n, n - 1_I4)
        bit_count = bit_count + 1
    end do
end function kernighan_count_bits
\end{verbatim}

\begin{enumerate}
\item \textbf{Brian Kernighan's Algorithm}:

\begin{itemize}
\item Each iteration clears the lowest set bit of \texttt{n} by doing \texttt{n = and(n, n - 1\_I4)}.
\item Increments the count of bits for each iteration.
\end{itemize}


\item \textbf{Performance}:

\begin{itemize}
\item Efficient when \texttt{n} has relatively few set bits.
\item The loop runs as many times as there are set bits, rather than the total number of bits.
\end{itemize}
\end{enumerate}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{8. \textbf{Binary Representation: \texttt{bit\_repr(val) result(repr)}}}

\begin{verbatim}
function bit_repr(val) result(repr)
    integer(kind=I4), value :: val
    character(len=32) :: repr
    integer :: i

    do i = 32, 1, -1
        if (and(val, 1_I4) == 1_I4) then
            repr(i:i) = '1'
        else
            repr(i:i) = '0'
        end if
        val = ishft(val, -1)
    end do
end function bit_repr
\end{verbatim}

\begin{enumerate}
\item \textbf{Purpose}: Converts a 32-bit integer into a fixed 32-character binary string.
\item \textbf{Implementation}:

\begin{itemize}
\item Iterates from bit position 32 down to 1.
\item Checks the least significant bit of \texttt{val} and sets \texttt{repr(i:i)} accordingly to \texttt{'1'} or \texttt{'0'}.
\item Shifts \texttt{val} right by 1.
\item The result is stored in a 32-character string, where \texttt{repr(1:1)} is the leftmost bit and \texttt{repr(32:32)} is the rightmost bit.
\end{itemize}


\item \textbf{Sign Bit}:

\begin{itemize}
\item For negative values, the leading bits will be the sign bits (in two's complement representation). Hence, you'll often see ones at the higher-order bits for negative integers.
\end{itemize}
\end{enumerate}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{9. \textbf{Key Observations and Takeaways}}

\begin{enumerate}
\item \textbf{Initialization and Encapsulation}:

\begin{itemize}
\item The approach of calling \texttt{ensure\_lookup\_table\_initialized()} inside each function ensures that external callers do not need to worry about whether the table is ready.
\item By marking the table and initialization logic private, the module retains control over how the data is loaded and accessed.
\end{itemize}


\item \textbf{Performance Trade-Offs}:

\begin{itemize}
\item \textbf{Naive} and \textbf{Early Stopping} methods rely on shifting all or some bits in a loop, straightforward but generally slower.
\item \textbf{Kernighan} method iterates only as many times as there are set bits.
\item \textbf{Lookup Table} method is typically the fastest for large volumes of data, because it reduces the problem to four table lookups.
\end{itemize}


\item \textbf{Error Handling}:

\begin{itemize}
\item The module checks for I/O issues (\texttt{ios} codes) when reading files.
\item If CSV reading fails, it uses \texttt{stop} statements to terminate the program with a nonzero exit code.
\end{itemize}


\item \textbf{CSV Preprocessing}:

\begin{itemize}
\item Because the CSV lines might contain trailing \texttt{, \&}, the subroutine \texttt{remove\_trailing\_comma\_ampersand} cleans each line. This is a helpful technique to ensure the data is in a standard CSV format when eventually read by \texttt{csv\_module}.
\end{itemize}


\item \textbf{Memory Usage}:

\begin{itemize}
\item The lookup table is only 256 integers in size, which is negligible in modern contexts. However, the code's design is scalable and well-structured if someone wanted to extend the concept to 16-bit or 64-bit segmented lookups.
\end{itemize}
\end{enumerate}


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{10. \textbf{Conclusion}}

\texttt{bitmanip\_mod.f90} is a well-structured module providing:

\begin{itemize}
\item \textbf{Multiple Bit-Counting Implementations}:

\begin{enumerate}
\item \textbf{Naive} (simple, guaranteed 32 iterations).
\item \textbf{Early Stopping} (slightly optimized naive approach).
\item \textbf{Lookup Table} (fast, relies on precomputed 8-bit partial counts).
\item \textbf{Kernighan's} (iterates by the number of set bits).
\end{enumerate}


\item \textbf{A Portable CSV-Loading Mechanism} that leverages a third-party CSV library and local string-manipulation utilities to populate the lookup table.
\item \textbf{Utility Function} (\texttt{bit\_repr}) for integer-to-binary-string conversion.
\item \textbf{Robust Initialization}: The separation of concerns between \texttt{ensure\_lookup\_table\_initialized} and \texttt{initialize\_lookup\_table} is clean, ensuring the lookup table is always valid when the public routines are called.
\end{itemize}

Overall, this module exemplifies good Fortran design practices: careful scoping, explicit initialization, and a range of performance-tuned subroutines for a specific bitwise manipulation problem.

\subparagraph{Program Code}

\subparagraph{bitcount.f90}

\begin{verbatim}
program bitcount
    use, intrinsic :: iso_fortran_env, only : error_unit
    use :: bitmanip_mod
    implicit none
    integer :: nr_vals
    integer(kind=I4), dimension(:), allocatable :: vals
    integer(kind=I4) :: result
    integer :: i, istat
    integer :: naive_count_bits_result, early_stopping_count_bits_result, &
        lookup_table_count_bits_result, kernighan_count_bits_result
    real :: r, start_time, end_time

    print '(A)', 'sanity check: naive, early stopping, lookup table Kernighan'
    do i = -16, 16
        naive_count_bits_result = naive_count_bits(i)
        early_stopping_count_bits_result = early_stopping_count_bits(i)
        lookup_table_count_bits_result = lookup_table_count_bits(i)
        kernighan_count_bits_result = kernighan_count_bits(i)

        !print '(I14, 3A, 4I3)', i, ': ', bit_repr(i), ': ', &
        !    naive_count_bits(i), early_stopping_count_bits(i), &
        !    lookup_table_count_bits(i), kernighan_count_bits(i)

        print '(I14, 3A, 4I3)', i, ': ', bit_repr(i), ': ', &
            naive_count_bits_result, early_stopping_count_bits_result, &
            lookup_table_count_bits_result, kernighan_count_bits_result
    end do

    ! create values upfront for benchmarking
    call get_arguments(nr_vals)
    allocate (vals(nr_vals), stat=istat)
    if (istat /= 0) then
        write (unit=error_unit, fmt='(A, I0, A)') 'error: can not allocate ', &
            nr_vals, ' elements'
        stop 3
    end if
    do i = 1, size(vals)
        call random_number(r)
        vals(i) = int(r*real(huge(0_I4)), kind=I4)
    end do

    ! time naive implmentation
    call cpu_time(start_time)
    do i = 1, size(vals)
        result = xor(result, naive_count_bits(vals(i)))
    end do
    call cpu_time(end_time)
    print '(A, I0, A, F35.15)', 'naive implementation ', size(vals), &
        ' iterations: ', end_time - start_time

    ! time early stopping implmentation
    call cpu_time(start_time)
    do i = 1, size(vals)
        result = xor(result, early_stopping_count_bits(vals(i)))
    end do
    call cpu_time(end_time)
    print '(A, I0, A, F35.15)', 'early stopping implementation ', size(vals), &
        ' iterations: ', end_time - start_time

    ! time lookup table implmentation
    call cpu_time(start_time)
    do i = 1, size(vals)
        result = xor(result, lookup_table_count_bits(vals(i)))
    end do
    call cpu_time(end_time)
    print '(A, I0, A, F35.15)', 'lookup table implementation ', size(vals), &
        ' iterations: ', end_time - start_time

    ! time Kernighan's algorithm
    call cpu_time(start_time)
    do i = 1, size(vals)
        result = xor(result, kernighan_count_bits(vals(i)))
    end do
    call cpu_time(end_time)
    print '(A, I0, A, F35.15)', 'Kernighan implementation ', size(vals), &
        ' iterations: ', end_time - start_time
contains

    subroutine get_arguments(nr_vals)
        use, intrinsic :: iso_fortran_env, only : error_unit
        implicit none
        integer, intent(out) :: nr_vals
        character(len=1024) :: buffer, msg
        integer :: istat

        if (command_argument_count() /= 1) then
            write (unit=error_unit, fmt='(A)') 'error: expecting number of values'
            write (unit=*, fmt='(A)') 'error: expecting number of values'
            stop 1
        end if
        call get_command_argument(1, buffer)
        read (buffer, fmt=*, iostat=istat, iomsg=msg) nr_vals
        if (istat /= 0) then
            write (unit=error_unit, fmt='(2A)') 'error: ', trim(msg)
            stop 2
        end if
    end subroutine get_arguments

end program bitcount
\end{verbatim}

\subparagraph{bitmanip\_mod.f90}

\begin{verbatim}
module bitmanip_mod
    use, intrinsic :: iso_fortran_env, only : INT32, error_unit
    use csv_module

    implicit none

    private

    ! A 256 -element lookup table stored in the module
    integer, public, parameter :: I4 = INT32
    integer(kind=I4), dimension(0:255), private :: lookup_table
    logical, private, save :: initialized = .false.

    ! Public procedures
    public :: naive_count_bits, early_stopping_count_bits, bit_repr, &
              lookup_table_count_bits, kernighan_count_bits

contains

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    !> Main routine that ensures the module lookup_table is initialized
    subroutine ensure_lookup_table_initialized()
        if (.not. initialized) then
            call initialize_lookup_table()
        end if
    end subroutine ensure_lookup_table_initialized

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    !> Initialize the module lookup_table by reading 256 integers from the CSV
    subroutine initialize_lookup_table()
        implicit none
        integer :: ios

        ! Clear the module array
        lookup_table = 0

        ! Call parse_csv_file to fill the local array
        call parse_csv_file("lookup_table.dat", lookup_table, ios)

        if (ios == 0) then
            initialized = .true.
        else
            write(error_unit, '(A,I0)') "Failed to read CSV lookup table, ios=", ios
            stop 1
        end if
    end subroutine initialize_lookup_table

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    !> Reads up to 256 integers from the CSV file using csv -fortrans get_csv_data_as_str
    subroutine parse_csv_file(filename, table_data, ios)
        !! Reads a CSV file that has trailing ", &" on each line,
        !! removing them before calling csv -fortran's get_csv_data_as_str.
        use csv_module
        
        implicit none

        ! Subroutine arguments
        character(len=*), intent(in)                                :: filename     ! Holds the name of the CSV file
        integer(kind=I4), dimension(0:255), intent(out)             :: table_data
        integer, intent(out)                                        :: ios          ! Error code

        ! Local variables
        type(csv_file)                                              :: c            ! csv -fortran object
        logical                                                     :: status_ok    ! Status flag for csv -fortran objects
        character(len=255), allocatable, dimension(:,:)             :: string_table ! Holds the CSV data as a table of strings
        integer                                                     :: nrow, ncol   ! Number of rows and columns in the CSV data
        integer :: i, j, idx, ios2, val
        character(len=30)                                           :: trimmed_string ! Holds the trimmed string which is a data cell

        !! For pre -processing:
        integer :: unit_in, unit_out, status_in, status_out
        character(len=1024) :: line, tmpfile
        logical :: done

        ! Initialize outputs
        ios = 0
        table_data = 0

        ! Generate a temp file name
        tmpfile = 'tempfile.csv'

        ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        !  STEP 1: Pre -process 'filename' => 'tempfile.csv'
        ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        open(newunit=unit_in, file=filename, status='old', action='read', &
            form='formatted', iostat=status_in)
        if (status_in /= 0) then
            write(*,*) "Error opening input file:", filename
            ios = 101 ! Error return code for opening input file
            return
        end if

        open(newunit=unit_out, file=tmpfile, status='replace', action='write', &
            form='formatted', iostat=status_out)
        if (status_out /= 0) then
            write(*,*) "Error creating temp file:", tmpfile
            ios = 102 ! Error return code for creating temp file
            close(unit_in)
            return
        end if

        do
            read(unit_in, '(A)', iostat=status_in) line
            if (status_in < 0) exit   ! EOF encountered
            if (status_in /= 0) then
                ios = 103 ! Error reading input file
                exit
            end if

            call remove_trailing_comma_ampersand(line)
            write(unit_out, '(A)') trim(line)
        end do

        close(unit_in)
        close(unit_out)

        if (ios /= 0) return  ! Error occurred

        ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        ! STEP 2: Use csv -fortran on tmpfile
        ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

        call c%initialize()
        call c%read(tmpfile, status_ok=status_ok)
        if (ios /= 0) then
            write(*,*) "Error reading temp CSV file:", tmpfile
            call c%close(status_ok)
            return
        end if

        call c%get(string_table, status_ok=status_ok)
        if (ios /= 0) then
            write(*,*) "Error extracting data as strings."
            call c%close(status_ok)
            return
        end if

        ! Parse up to 256 integers
        nrow = size(string_table,1)
        ncol = size(string_table,2)

        idx = 0
        do i = 1, nrow
            do j = 1, ncol
                trimmed_string = adjustl(adjustl(string_table(i,j)))
                read(trimmed_string, *) val
                table_data(idx) = val
                idx = idx + 1
            end do
        end do

        ! Close CSV
        call c%close(status_ok)

        deallocate(string_table)

    end subroutine parse_csv_file

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    subroutine remove_trailing_comma_ampersand(line)
        implicit none
        character(len=*), intent(inout) :: line
        integer :: n
    
        n = len_trim(line)
        if (n < 1) return ! Nothing to do
    
        ! Remove trailing "&"
        do while (n > 0)
            if (line(n:n) == "&") then
                line(n:n) = ""
                n = n - 1
            else
                exit
            end if
        end do
    
        ! Remove trailing ", "
        do while (n >= 2)
            if (line(n -1:n) == ", ") then
                line(n -1:n) = ""
                n = n - 2
            else
                exit
            end if
        end do
    end subroutine remove_trailing_comma_ampersand    

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    !> Bit -counting routines that rely on the lookup_table
    function naive_count_bits(n) result(bit_count)
        implicit none
        integer(kind=I4), value :: n
        integer :: bit_count
        integer :: i

        call ensure_lookup_table_initialized()

        bit_count = 0
        do i = 1, 32
            bit_count = bit_count + and(n, 1_I4)
            n = ishft(n, -1)
        end do
    end function naive_count_bits

    function early_stopping_count_bits(n) result(bit_count)
        implicit none
        integer(kind=I4), value :: n
        integer :: bit_count
        integer :: i

        call ensure_lookup_table_initialized()

        bit_count = 0
        do i = 1, 32
            bit_count = bit_count + and(n, 1_I4)
            n = ishft(n, -1)
            if (n == 0) exit
        end do
    end function early_stopping_count_bits

    function lookup_table_count_bits(n) result(bit_count)
        implicit none
        integer(kind=I4), value :: n
        integer :: bit_count

        call ensure_lookup_table_initialized()

        ! The lookup table is now loaded
        bit_count = lookup_table(and(n, 255_I4)) + &
                    lookup_table(and(ishft(n, -8), 255_I4)) + &
                    lookup_table(and(ishft(n, -16), 255_I4)) + &
                    lookup_table(and(ishft(n, -24), 255_I4))
    end function lookup_table_count_bits

    function kernighan_count_bits(n) result(bit_count)
        implicit none
        integer(kind=I4), value :: n
        integer :: bit_count

        call ensure_lookup_table_initialized()

        bit_count = 0
        do while (n /= 0)
            n = and(n, n - 1_I4)
            bit_count = bit_count + 1
        end do
    end function kernighan_count_bits

    function bit_repr(val) result(repr)
        implicit none
        integer(kind=I4), value :: val
        character(len=32) :: repr
        integer :: i

        do i = 32, 1, -1
            if (and(val, 1_I4) == 1_I4) then
                repr(i:i) = '1'
            else
                repr(i:i) = '0'
            end if
            val = ishft(val, -1)
        end do
    end function bit_repr

end module bitmanip_mod
\end{verbatim}

The above program is compiled and run using Fortran Package Manager (fpm).  The following FPM configuration file (fpm.toml) was used:

\begin{verbatim}
name = "Section_Bit_Manipulations_Bit_Count"

[build]
auto -executables = true
auto -tests = true
auto -examples = true

[install]
library = false

[dependencies]
csv -fortran = {git="https://github.com/jacobwilliams/csv -fortran.git"}

[[executable]]
name="Section_Bit_Manipulations_Bit_Count"
source -dir="app"
main="section_bit_manipulations_bit_count.f90"
\end{verbatim}

\subparagraph{Build the Program using FPM (Fortran Package Manager)}

\begin{verbatim}
import os
root_dir = ""
root_dir = os.getcwd()
\end{verbatim}

\begin{verbatim}
code_dir = root_dir + "/" + "Fortran_Code/Section_Bit_Manipulations_Bit_Count"
\end{verbatim}

\begin{verbatim}
os.chdir(code_dir)
\end{verbatim}

\begin{verbatim}
build_status = os.system("fpm build 2>/dev/null")
\end{verbatim}

\subparagraph{Run the Program using FPM (Fortran Package Manager)}

The program is run and the output is saved into a file named 'data.dat

\begin{verbatim}
exec_status = \
    os.system("fpm run - - 1024 2>/dev/null")
\end{verbatim}

\begin{verbatim}
sanity check: naive, early stopping, lookup table Kernighan
           -16: 11111111111111111111111111110000:  28 28 28 28
           -15: 11111111111111111111111111110001:  29 29 29 29
           -14: 11111111111111111111111111110010:  29 29 29 29
           -13: 11111111111111111111111111110011:  30 30 30 30
           -12: 11111111111111111111111111110100:  29 29 29 29
           -11: 11111111111111111111111111110101:  30 30 30 30
           -10: 11111111111111111111111111110110:  30 30 30 30
            -9: 11111111111111111111111111110111:  31 31 31 31
            -8: 11111111111111111111111111111000:  29 29 29 29
            -7: 11111111111111111111111111111001:  30 30 30 30
            -6: 11111111111111111111111111111010:  30 30 30 30
            -5: 11111111111111111111111111111011:  31 31 31 31
            -4: 11111111111111111111111111111100:  30 30 30 30
            -3: 11111111111111111111111111111101:  31 31 31 31
            -2: 11111111111111111111111111111110:  31 31 31 31
            -1: 11111111111111111111111111111111:  32 32 32 32
             0: 00000000000000000000000000000000:   0  0  0  0
             1: 00000000000000000000000000000001:   1  1  1  1
             2: 00000000000000000000000000000010:   1  1  1  1
             3: 00000000000000000000000000000011:   2  2  2  2
             4: 00000000000000000000000000000100:   1  1  1  1
             5: 00000000000000000000000000000101:   2  2  2  2
             6: 00000000000000000000000000000110:   2  2  2  2
             7: 00000000000000000000000000000111:   3  3  3  3
             8: 00000000000000000000000000001000:   1  1  1  1
             9: 00000000000000000000000000001001:   2  2  2  2
            10: 00000000000000000000000000001010:   2  2  2  2
            11: 00000000000000000000000000001011:   3  3  3  3
            12: 00000000000000000000000000001100:   2  2  2  2
            13: 00000000000000000000000000001101:   3  3  3  3
            14: 00000000000000000000000000001110:   3  3  3  3
            15: 00000000000000000000000000001111:   4  4  4  4
            16: 00000000000000000000000000010000:   1  1  1  1
naive implementation 1024 iterations:                   0.000079999910668
early stopping implementation 1024 iterations:                   0.000055999960750
lookup table implementation 1024 iterations:                   0.000004000030458
Kernighan implementation 1024 iterations:                   0.000035000033677
\end{verbatim}

\subparagraph{Program Output Interpretation by ChatGPT 4o1}

\subparagraph{1. \textbf{Sanity Check Results}}

\subparagraph{1.1 \textbf{Verification of Four Methods}}

From -16 through 16, the program prints:

\begin{enumerate}
\item \textbf{Integer value} (e.g., -16, -15, 0, 1, 2, etc.).
\item \textbf{32-bit binary representation} of the integer (two's complement for negatives).
\item \textbf{Four integers}: the bit-count results for each method

\begin{itemize}
\item \textbf{Naive} (\texttt{naive\_count\_bits})
\item \textbf{Early Stopping} (\texttt{early\_stopping\_count\_bits})
\item \textbf{Lookup Table} (\texttt{lookup\_table\_count\_bits})
\item \textbf{Kernighan} (\texttt{kernighan\_count\_bits})
\end{itemize}
\end{enumerate}

For instance:

\begin{verbatim}
-16: 11111111111111111111111111110000:  28 28 28 28
...
 16: 00000000000000000000000000010000:   1  1  1  1
\end{verbatim}

\textbf{Significance}:

\begin{enumerate}
\item All methods produce \textbf{identical} counts for each integer, confirming the \textbf{correctness and consistency} of the four implementations.
\item Negative integers (e.g., -1, -2, etc.) appear in \textbf{two's complement} form, hence the leading bits are \texttt{1}. That explains large bit counts for values like -1 (32 ones \rightarrow bit count = 32).
\end{enumerate}

\subparagraph{1.2 \textbf{Specific Observations}}

\begin{itemize}
\item \textbf{-1}:\newline
Binary is all ones (\texttt{111111...1111}), yielding a bit count of 32 for each method.
\item \textbf{-16}:\newline
Binary ends in \texttt{11110000}. Because -16 has four zeros at the lower end and ones in the high positions, the bit count is 28.
\item \textbf{Small Positive Values}:\newline
For example, 3 is \texttt{000000...0011} with a count of 2 bits.\newline
For 15 (\texttt{00000000000000000000000000001111}), the bit count is 4.
\end{itemize}

These results ensure that the range from negative to positive integers is correctly handled.


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{2. \textbf{Timing and Performance}}

After the sanity check, the program runs 1024 iterations of each bit-counting method on some dataset (in this snippet, presumably 1024 integers), printing the elapsed \textbf{CPU time}. Example output:

\begin{verbatim}
naive implementation 1024 iterations:                   0.000079999910668
early stopping implementation 1024 iterations:          0.000055999960750
lookup table implementation 1024 iterations:            0.000004000030458
Kernighan implementation 1024 iterations:               0.000035000033677
\end{verbatim}

\textbf{Interpretation}:

\begin{enumerate}
\item \textbf{Naive} (0.00008s)

\begin{itemize}
\item Checks each of 32 bits unconditionally for each integer.
\item Takes the most time (though still small), indicative of a higher overhead approach.
\end{itemize}


\item \textbf{Early Stopping} (0.00006s)

\begin{itemize}
\item Similar logic to Naive, but exits the loop early if the remaining bits are zero.
\item Slightly faster than Naive in many cases.
\end{itemize}


\item \textbf{Lookup Table} (0.000004s)

\begin{itemize}
\item Significantly faster because it counts bits by splitting each 32-bit integer into four 8-bit chunks and uses a \textbf{precomputed table} of the bit counts for each byte.
\item Fast constant time lookups dominate here.
\end{itemize}


\item \textbf{Kernighan} (0.000035s)

\begin{itemize}
\item Uses \texttt{n = n \& (n - 1)}, clearing one set bit per iteration.
\item Performance depends on the number of set bits, not all 32.
\item Often quite efficient, though typically not quite as fast as table lookups for a large batch of random data.
\end{itemize}
\end{enumerate}

Hence, the performance ordering in this particular test shows \textbf{Lookup Table} as the fastest, followed by \textbf{Kernighan}, \textbf{Early Stopping}, and then \textbf{Naive}.


\bigskip
\centerline{\rule{13cm}{0.4pt}}
\bigskip

\subparagraph{3. \textbf{Overall Significance}}

\begin{itemize}
\item \textbf{Correctness Check}: The first part (the ``sanity check'') assures that for any integer in $[ -16,16]$, all four methods return the \textbf{same} bit-count. This validates the \textbf{integrity} of each algorithm.
\item \textbf{Performance Comparison}: The second part (timing) highlights the \textbf{efficiency trade-offs} between the methods. It illustrates how a \textbf{lookup table} can drastically reduce execution time when counting bits repeatedly, while \textbf{Kernighan} can also be quite efficient depending on the data distribution.
\end{itemize}

Thus, the output \textbf{both} \textbf{confirms} that each bit-counting approach works correctly \textbf{and} demonstrates the \textbf{relative performance} of each algorithm over 1024 iterations.