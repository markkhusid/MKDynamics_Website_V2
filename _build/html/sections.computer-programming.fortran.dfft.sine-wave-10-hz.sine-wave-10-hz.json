{"version":3,"kind":"Article","sha256":"181f5b0fe207d68a8fe19033b7e5d5573d9d1a1e6af52b64ff75a7e2a19e5e81","slug":"sections.computer-programming.fortran.dfft.sine-wave-10-hz.sine-wave-10-hz","location":"/Sections/Computer_Programming/Fortran/DFFT/Sine_Wave_10_Hz/sine_wave_10_hz.md","dependencies":[],"frontmatter":{"title":"Sine Wave at 10Hz","content_includes_title":false,"authors":[{"nameParsed":{"literal":"Mark Khusid","given":"Mark","family":"Khusid"},"name":"Mark Khusid","id":"contributors-myst-generated-uid-0"}],"github":"https://github.com/markkhusid/MKDynamics_Website_V2","numbering":{"title":{"offset":4}},"source_url":"https://github.com/markkhusid/MKDynamics_Website_V2/blob/master/Sections/Computer_Programming/Fortran/DFFT/Sine_Wave_10_Hz/sine_wave_10_hz.md","edit_url":"https://github.com/markkhusid/MKDynamics_Website_V2/edit/master/Sections/Computer_Programming/Fortran/DFFT/Sine_Wave_10_Hz/sine_wave_10_hz.md","thumbnail":"/build/scilab_sine_wave2_10-146d1db1cc1d94d1acc00b99beb500a3.jpeg","thumbnailOptimized":"/build/scilab_sine_wave2_10-146d1db1cc1d94d1acc00b99beb500a3.webp","exports":[{"format":"md","filename":"sine_wave_10_hz.md","url":"/build/sine_wave_10_hz-c2b5caccae63fbf2b00686147505c112.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"heading","depth":2,"position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Introduction","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"P6srLkid54"}],"identifier":"introduction","label":"Introduction","html_id":"introduction","implicit":true,"key":"APBx9J33D1"},{"type":"paragraph","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"children":[{"type":"text","value":"This example demonstrates the computation of the Discretized Fourier Transform of a sine wave at 10 Hz using the FFTW3 library in Fortran. The sine wave is generated using SciLAB and the DFFT is computed using the Fortran 2003 code. The time domain and frequency domain plots are generated using GNUPlot.","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"cl4iwbWyzT"}],"key":"PA21Vp8SKI"},{"type":"heading","depth":2,"position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"children":[{"type":"text","value":"SciLAB Code","position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"key":"WV2gjsU1s0"}],"identifier":"scilab-code","label":"SciLAB Code","html_id":"scilab-code","implicit":true,"key":"BGmWZGAv5q"},{"type":"paragraph","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"The SciLAB code to generate the sine wave is as follows:","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"Qa1VPEukiw"}],"key":"ZiUQVYVuYn"},{"type":"code","lang":"scilab","value":"// Generate a sine wave at 10 Hz\n// Frequency components of a signal\n//----------------------------------\n// build a signal sampled at 1000hz  containing a pure frequency\n// at 10Hz\nsample_rate=1000;\nfrequency=10;\n\n// time vector which goes from 0 to 1 with a step of 1/sample_rate\nt = 0:1/sample_rate:1;\n\n// number of samples\nN=size(t,'*'); //number of samples\n\n// generate the signal\ns=sin(2*%pi*frequency*t);\n\n// compute the fft of the signal\ny=fft(s);\n\n//s is real so the fft response is conjugate symmetric and we retain only the first N/2 points\nf=sample_rate*(0:(N/2))/N; //associated frequency vector\n\n// number of samples\nn=size(f,'*')\n\n// plot the fft\nh=0;\nscf(h);\nxset('window',h);\nxtitle('DFFT of 10Hz Sine Wave in SciLAB', 'Freq [Hz]', 'Amplitude [Arb]');\nplot(f,abs(y(1:n)))\n\n// plot the time domain signal\nh=1;\nscf(h);\nxset('window',h);\nxtitle('s(t)', 'Time [s]', 'Amplitude [Arb]');\nplot(t, s);","position":{"start":{"line":8,"column":1},"end":{"line":48,"column":1}},"key":"u0M0PokWtX"},{"type":"heading","depth":2,"position":{"start":{"line":50,"column":1},"end":{"line":50,"column":1}},"children":[{"type":"text","value":"Execute the SciLAB Code","position":{"start":{"line":50,"column":1},"end":{"line":50,"column":1}},"key":"Ch589GyOYG"}],"identifier":"execute-the-scilab-code","label":"Execute the SciLAB Code","html_id":"execute-the-scilab-code","implicit":true,"key":"aqfytJJ92G"},{"type":"paragraph","position":{"start":{"line":51,"column":1},"end":{"line":51,"column":1}},"children":[{"type":"text","value":"To execute the SciLAB code, copy and paste the code into the SciLAB console and press Enter.  The time domain and frequency domain plots will be displayed.  The results are shown below:","position":{"start":{"line":51,"column":1},"end":{"line":51,"column":1}},"key":"A8CyNdVxWk"}],"key":"fEJts2eojx"},{"type":"heading","depth":3,"position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"children":[{"type":"text","value":"Time Domain Plot","position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"key":"Ah7WM0pXtl"}],"identifier":"time-domain-plot","label":"Time Domain Plot","html_id":"time-domain-plot","implicit":true,"key":"Tny1RESDax"},{"type":"image","url":"/build/scilab_sine_wave2_10-146d1db1cc1d94d1acc00b99beb500a3.jpeg","align":"center","key":"jqU5YhFzVd","urlSource":"images/scilab_sine_wave2_10Hz.jpeg","urlOptimized":"/build/scilab_sine_wave2_10-146d1db1cc1d94d1acc00b99beb500a3.webp"},{"type":"heading","depth":3,"position":{"start":{"line":59,"column":1},"end":{"line":59,"column":1}},"children":[{"type":"text","value":"Frequency Domain Plot","position":{"start":{"line":59,"column":1},"end":{"line":59,"column":1}},"key":"G5PlLDWqip"}],"identifier":"frequency-domain-plot","label":"Frequency Domain Plot","html_id":"frequency-domain-plot","implicit":true,"key":"sBQYtRzlZA"},{"type":"image","url":"/build/scilab_sine_wave2_10-3ffad714a4eaa18126243fed2f05e58d.jpg","align":"center","key":"Tb8eaCWZS5","urlSource":"images/scilab_sine_wave2_10Hz_FFT.jpg","urlOptimized":"/build/scilab_sine_wave2_10-3ffad714a4eaa18126243fed2f05e58d.webp"},{"type":"heading","depth":2,"position":{"start":{"line":65,"column":1},"end":{"line":65,"column":1}},"children":[{"type":"text","value":"Saving The Time Domain Data","position":{"start":{"line":65,"column":1},"end":{"line":65,"column":1}},"key":"UJC1JjFPkX"}],"identifier":"saving-the-time-domain-data","label":"Saving The Time Domain Data","html_id":"saving-the-time-domain-data","implicit":true,"key":"bkDouPNiGc"},{"type":"paragraph","position":{"start":{"line":66,"column":1},"end":{"line":66,"column":1}},"children":[{"type":"text","value":"The time-domain data is selected in SciLAB and saved into a CSV file.","position":{"start":{"line":66,"column":1},"end":{"line":66,"column":1}},"key":"sLeTIJi3Ud"}],"key":"ZZ6vjZQqBq"},{"type":"heading","depth":2,"position":{"start":{"line":68,"column":1},"end":{"line":68,"column":1}},"children":[{"type":"text","value":"Processing of CSV File into a Format Suitable for Input into the Fortran 2003 DFFT Code","position":{"start":{"line":68,"column":1},"end":{"line":68,"column":1}},"key":"cN4xoLQlF5"}],"identifier":"processing-of-csv-file-into-a-format-suitable-for-input-into-the-fortran-2003-dfft-code","label":"Processing of CSV File into a Format Suitable for Input into the Fortran 2003 DFFT Code","html_id":"processing-of-csv-file-into-a-format-suitable-for-input-into-the-fortran-2003-dfft-code","implicit":true,"key":"A5WFOBQQdt"},{"type":"paragraph","position":{"start":{"line":69,"column":1},"end":{"line":72,"column":1}},"children":[{"type":"text","value":"Since the output of SciLAB is a comma separated value (CSV) file, a method is needed that will process that file into another file, where the commas are removed and each data element is on a separate line.\nAdditionally, a the data elements need to be reformatted into fixed floating point, since the “e”\nfloating point format was noticed to possibly cause errors when input into the FFTW3 algorithm.\nThese operations were done using a Python script, with its powerful object-oriented file techniques and its included CSV library. The Python script is shown below:","position":{"start":{"line":69,"column":1},"end":{"line":69,"column":1}},"key":"JagWvnVwf4"}],"key":"xe4wrJ4Wdn"},{"type":"code","lang":"python","value":"#!/usr/bin/python3\nimport sys\nimport csv\nimport os\n\n# Assign constants for better code readability\nfirst_arg = 1\nsecond_arg = 2\n\n# Call the system to get the command line arguments and pull out items from the list\ninput_file = sys.argv[first_arg]\nintermediate_file = 'intermediate.dat'\noutput_file = sys.argv[second_arg]\n\n# Simple string manipulation that traverses text file until EOF \n# and calls method to replace commas with newline characters\nwith open(input_file) as infile, open(intermediate_file, \"w\") as outfile:\n  for line in infile:\n      outfile.write(line.replace(\",\", \"\\n\"))\n\n# Close the input file, as it is no longer needed.\ninfile.close()\n      \n# Now go through the intermediate file (the file that contains one data element per line)\n# and reformat all of the data elements into fixed floating point with 20 decimal precision.\nwith open(intermediate_file) as infile, open(output_file, \"w\") as outfile:\n  for line in infile:\n      outfile.write('%20.20f\\n' % float(line))\n            \n# Close the intermediate file and final output file.\ninfile.close()\noutfile.close()\n\n# Clean away the intermediate file.  The next line may be commented out if the intermediate \n# file is required.\nos.remove(intermediate_file)","position":{"start":{"line":74,"column":1},"end":{"line":111,"column":1}},"key":"WhiNNY4bEM"},{"type":"heading","depth":2,"position":{"start":{"line":113,"column":1},"end":{"line":113,"column":1}},"children":[{"type":"text","value":"Execute the Python Script","position":{"start":{"line":113,"column":1},"end":{"line":113,"column":1}},"key":"Rc8wKhhtA8"}],"identifier":"execute-the-python-script","label":"Execute the Python Script","html_id":"execute-the-python-script","implicit":true,"key":"Fqdz7oD2gZ"},{"type":"paragraph","position":{"start":{"line":114,"column":1},"end":{"line":114,"column":1}},"children":[{"type":"text","value":"Run by typing:","position":{"start":{"line":114,"column":1},"end":{"line":114,"column":1}},"key":"reqtFn75eZ"}],"key":"lGoJwZFbcS"},{"type":"code","lang":"bash","value":"./convert_csv.py infile.csv outfile.dat","position":{"start":{"line":115,"column":1},"end":{"line":117,"column":1}},"key":"r8tYZOcElM"},{"type":"paragraph","position":{"start":{"line":119,"column":1},"end":{"line":120,"column":1}},"children":[{"type":"text","value":"where infile.csv is the data file in CSV format, and outfile.dat is the processed file\nObtain the line count of the processed file by typing:","position":{"start":{"line":119,"column":1},"end":{"line":119,"column":1}},"key":"Bfz6fGhlQl"}],"key":"dEj7qNcSM6"},{"type":"code","lang":"bash","value":"wc -l outfile.dat","position":{"start":{"line":122,"column":1},"end":{"line":124,"column":1}},"key":"rqpIsr0Mv8"},{"type":"heading","depth":2,"position":{"start":{"line":126,"column":1},"end":{"line":126,"column":1}},"children":[{"type":"text","value":"Fortran 2003 Code","position":{"start":{"line":126,"column":1},"end":{"line":126,"column":1}},"key":"GW3j4QYkFJ"}],"identifier":"fortran-2003-code","label":"Fortran 2003 Code","html_id":"fortran-2003-code","implicit":true,"key":"EdSGOc6uS7"},{"type":"paragraph","position":{"start":{"line":127,"column":1},"end":{"line":127,"column":1}},"children":[{"type":"text","value":"The Fortran 2003 code to compute the Discretized Fourier Transform of the sine wave at 10 Hz is as follows:","position":{"start":{"line":127,"column":1},"end":{"line":127,"column":1}},"key":"pNtFMkDNjy"}],"key":"Vx4P6JNfbt"},{"type":"include","file":"../code/dfft_fftw3.f08","literal":true,"children":[{"type":"code","value":"\n\n! DFFT from Processed Data File\n! Written by Mark Khusid 2015\n!\n! 2018\n! Version 6\n! Increased amount of command line arguments to 5 from 3.  The added two were sample rate and number of periods.\n! Cleaned up indentation and formatting.\n! Modified the write_DFFT_to_file subroutine to output not only the DFFT data element but also the corrected frequency\n! on each line of the data file.  The DFFT data element and corrected frequency are separated by a space\n! Obtained the corrected frequency based on the sampe rate and the next power of two of the total number of samples (i.e. 100 samples -> next power of 2 = 128.)\n! Since there are num_bins_int number of data elements in FFT array, and the FFT array is symmetric, we divide the magnitude by half the num_bins_int to get the normalized magnitude.\n!\n! Version 5\n! Commented out debug code and rearranged some inconsequential lines.\n!\n! 2015\n! Version 4\n! Numerous fixes.  Changed code to allocate memory based on the next power of 2 relative\n! to the number of element in the input file.  For example, a data file with 1000 data elements\n! will cause arrays to be allocated with 1024 elements.  This is done to prevent errors in the FFT.\n! Extra array space above and beyond what is in data file is padded with zeros.\n! Reformatted most of the debug output.\n! Used ATAN2, separate variables and formatting to ensure that small values of the real part will not \n! cause phase errors.\n!\n! Version 3\n! This version counts the number of data elements in the file automatically.\n! This version is rewritten to make use of subroutines.\n\nmodule MKDynamics_FFT\n\n    use, intrinsic      :: iso_c_binding\n      include 'fftw3.f03'\n      \n      type(C_PTR)         \t\t\t:: plan\n      \n      ! Input file name, output file name and number of bins, sample rate, number of periods\n      integer, parameter                                      :: num_expected_args = 5\n      \n      ! FFTW input array\n      real(C_DOUBLE), dimension(:), allocatable\t\t\t    :: in\n      \n      ! FFTW output array\n      complex(C_DOUBLE_COMPLEX), dimension(:), allocatable\t:: out\n      \n      ! Holds the data read from the input file\n      real(C_DOUBLE), dimension(:), allocatable   \t\t\t                :: temp_real_array\n      \n      ! Used to perform complex math\n      real(C_DOUBLE)                                                                      :: magnitude, phase, temp_real\n      \n      ! For checking if EOF reached\n      integer                                                                             :: EOF_marker\n      \n      ! For checking if files opened successfully\n      integer                                     \t\t\t                :: file_good1, file_good2, file_good3\n      \n      ! For checking if files written successfully\n      integer                                                                             :: good_write1, good_write2\t\t\t\n      \n      ! Counter used to traverse arrays\n      integer                     \t\t\t\t\t\t\t:: i\n      \n      ! Contains number of arguments for verification of proper command line call\n      integer                     \t\t\t\t\t\t\t:: num_args\n      \n      ! Holds obtained number of bins\n      integer                     \t\t\t\t\t\t\t:: num_bins_int\n      \n      ! Holds memory allocation status of arrays\n      integer\t\t\t\t\t\t                           \t:: status1, status2, status3\n      \n      ! Holds file names\n      character(len=80)               \t\t\t\t\t\t:: input_file, output_mag_file\n      character(len=80)\t\t\t\t                   \t\t:: output_phase_file\n      \n      ! Holds sample rate argument string that will be converted to an integer\n      character(len=80)                                       :: sample_rate_string\n      \n      ! Holds number of periods argument string that will be converted to an integer\n      character(len=80)                                       :: num_periods_string\n      \n      ! Used to calculate the next power of 2 above input file size.  i.e. 1000 element array is increased to 1024 elements\n      real\t\t\t                         \t\t\t\t:: num_log2_bins_real\n      integer\t\t\t\t\t\t\t                        :: num_bins_int_pow2\n      \n      ! Used to hold the sample rate of the input data file\n      integer                                                 :: sample_rate\n      \n      ! Used to hold the number of periods of the input data file\n      integer                                                 :: num_periods\n      \n      ! Used to hold the total number of samples within the input data file\n      integer                                                 :: num_samples\n         \n    contains\n      subroutine close_files_and_exit\n        close(1)\n        close(10)\n        close(20)\n        print *, 'Files closed.....'\n        print *, 'Exiting.....'\n        stop\n      end subroutine close_files_and_exit\n      \n      subroutine close_files_deallocate_and_exit(state)\n        integer :: state\n        close (1)\n        close (10)\n        close (20)\n        deallocate (in)\n        deallocate (out)\n        deallocate (temp_real_array)\n          if (state .eq. -1) then\n              print *, 'Files closed and memory deallocated'\n              print *, 'Exiting.....'\n          stop\n          else\n              print *, 'Files closed and memory deallocated'\n          end if\n      end subroutine close_files_deallocate_and_exit\n      \n      ! From stack overflow\n      elemental subroutine str2int(str,int)\n          implicit none\n          ! Arguments\n          character(len=*),intent(in) :: str\n          integer,intent(out)         :: int\n  \n          read(str,*)  int\n      end subroutine str2int\n      \n      subroutine get_args\n      ! Verify that the number of arguments is correct.  Should be 5, otherwise display\n        ! error and terminate program\n        num_args = command_argument_count()\n          if (num_args .ne. num_expected_args) then\n              print *, 'Improper number of arguments'\n              print *, 'Argument list:'\n              print *, '<input file name> <output magnitude file name> <output phase file name> <sample rate> <number of periods>' \n              call close_files_and_exit\t! Graceful exit, no cleanup  \n          end if\n        \n        ! Call subroutines that obtain the command line arguments and load the appropriate variables\n        call get_command_argument (1, input_file)\n        call get_command_argument (2, output_mag_file)\n        call get_command_argument (3, output_phase_file)\n        call get_command_argument (4, sample_rate_string)\n        call get_command_argument (5, num_periods_string)\n        \n        ! Debug code that ensures command line arguments were passed in properly\n        print *, 'The first argument is (input file name) ->'\n        print *, input_file\n        \n        print *, 'The second argument is (output magnitude file name) ->'\n        print *, output_mag_file\n        \n        print *, 'The third argument is (output phase file name) ->'\n        print *, output_phase_file\n        \n        print *, 'The fourth argument is (sample rate) as string ->'\n        print *, sample_rate_string\n        call str2int(sample_rate_string, sample_rate)\n        print *, 'The fourth argument is (sample rate) as integer ->'\n        print *, sample_rate\n        \n        print *, 'The fifth argument is (number of periods) as string ->'\n        print *, num_periods_string\n        call str2int(num_periods_string, num_periods)\n        print *, 'The fifth argument is (number of periods) as integer ->'\n        print *, num_periods\n        \n      end subroutine get_args\n    \n      subroutine open_files\n      ! Begin to open files\n        open (unit=1, file=TRIM(input_file), status=\"old\", IOSTAT=file_good1, form=\"formatted\", access=\"sequential\", action=\"read\")\n        !open (unit=1, file=TRIM(input_file), IOSTAT=file_good1)\n        if (file_good1 .ne. 0) then\n          print *, 'Error opening input file!'\n          call close_files_and_exit\t! Graceful exit, no cleanup  \n        else if (file_good1 .eq. 0) then\n          print *, 'Input file opened successfully...'\n        end if\n        \n        open (unit=10, file=TRIM(output_mag_file), status=\"replace\", IOSTAT=file_good2, form=\"formatted\", access=\"sequential\")\n        if (file_good2 .ne. 0) then\n          print *, 'Error creating output magnitude file!'\n          call close_files_and_exit\t! Graceful exit, no cleanup  \n        else if (file_good2 .eq. 0) then\n          print *, 'Output magnitude file created successfully...'\n        end if\n  \n        open (unit=20, file=TRIM(output_phase_file), status=\"replace\", IOSTAT=file_good3, form=\"formatted\", access=\"sequential\")\n        if (file_good3 .ne. 0) then\n          print *, 'Error creating output phase file!'\n          call close_files_and_exit\t! Graceful exit, no cleanup  \n        else if (file_good3 .eq. 0) then\n          print *, 'Output phase file created successfully...'\n        end if\n  \n      !   Debug code follows.  Tests to see if file opened properly.\n        read (unit=1, fmt='(f20.10)', IOSTAT = EOF_marker) temp_real\n        print *, 'The status of EOF_marker is'\n        print *, EOF_marker\n        print *, 'The first element read was'\n        print *, temp_real\n      !   Debug code ends\n        end subroutine open_files\n      \n      subroutine get_num_data_elements\n        ! Traverse through data file and count number of data elements in file\n        ! Get first data element from file to see whether it is the EOF character\n          print *, 'Entering get_num_data_elements procedure'\n          print *\n          i = 1\n          rewind(1)\n          read (1, '(f30.20)', IOSTAT = EOF_marker) temp_real\n      !\tDebug code starts here\n          write (*, '(a, i4)') 'The counter is ->', i\n          write (*, '(a, f30.20)') 'The first data element was ->', temp_real\n          write (*, '(a, i4)') 'The EOF marker is ->', EOF_marker\n      !\tprint *\n      ! \tprint *\n      !\tDebug code ends here\n  \n          if (EOF_marker < 0) then\n              print *, 'ERROR: Input file is empty'\n              call close_files_and_exit\t! Graceful exit, no cleanup  \n          end if\n  \n        ! Establish loop that will count number of elements in file\n          count_loop: do\n              if (EOF_marker < 0) then\n                  print *, 'EOF reached'\n                  exit count_loop\n              else\n                  i = i + 1\n                  read (1, '(f30.20)', IOSTAT = EOF_marker) temp_real\n                  !write (*, '(a, i4, a, f30.20)'), 'The data element at', i, ' was ->', temp_real\n                  !write (*, '(a, i4)'), 'The EOF_marker is ->', EOF_marker\n              end if\n          end do count_loop\n  \n          ! Copy over the number of counted elements into the num_bins_int variable less one for the EOF character\n          num_bins_int = i - 1\n          write (*, '(a, i10)') 'The number of lines in the input file is ->', num_bins_int\n          print *, 'Exiting get_num_data_elements procedure'\n          print *\n      end subroutine get_num_data_elements\n    \n      subroutine allocate_memory\n      \n      ! Allocate memory based on the number of bins\n      ! The number of bins will be used to find the next power of 2.\n      ! Display success status of memory allocation\n      ! If there is a problem with memory allocation, display error and terminate\n      \n          print *, 'Entering allocate_memory procedure'\n          print *\n          num_log2_bins_real = log(real(num_bins_int))/log(real(2))\n          write (*, '(a, f20.4)') 'The closest log base 2 bins is (as real)->', num_log2_bins_real\n          num_bins_int_pow2 = 2**(ceiling(num_log2_bins_real))\n          write (*, '(a, i8)') 'The closest number of power of 2 bins is (as integer)->', num_bins_int_pow2\n      \n          allocate (in(num_bins_int_pow2), stat=status1)\n          print *\n          write (*, '(a, l)') 'Was memory allocated successfully for input array? ->', allocated(in)  \n          if (status1 .ne. 0) then\n              print *, 'Memory allocation error on input array'\n              call close_files_and_exit\t! Graceful exit, no cleanup  \n          end if\n          write (*, '(a, i10)') 'Input Array allocated with size ->', size(in)\n      \n          allocate (out(num_bins_int_pow2), stat=status2)\n          print *\n          write (*, '(a, l)') 'Was memory allocated successfully for output array? ->', allocated(out)  \n          if (status2 .ne. 0) then\n              print *, 'Memory allocation error on output array'\n              deallocate (in)\n              call close_files_and_exit\t! Graceful exit, no cleanup  \n          end if\n          write (*, '(a, i10)') 'Output Array allocated with size ->', size(out)\n      \n          allocate (temp_real_array(num_bins_int_pow2), stat=status3)\n          print *\n          write (*, '(a, l)') 'Was memory allocated successfully for scratchpad array? ->', allocated(temp_real_array)  \n          if (status3 .ne. 0) then\n              print *, 'Memory allocation error on scratchpad array'\n              deallocate (in)\n              deallocate (out)\n              call close_files_and_exit\t! Graceful exit, no cleanup  \n          end if\n          write (*, '(a, i10)') 'Scratchpad Array allocated with size ->', size(temp_real_array)\n          print *, 'Exiting allocate_memory procedure'\n          print *\n      end subroutine allocate_memory\n        \n      subroutine read_from_file_into_array\n      ! Establish a loop that reads the file from 1 to num_bins_int\n      ! Bring file pointer for input file back to first element \n          print *, '***** Subroutine read_from_file_into_array ******'\n          rewind(1)\n          do i=1, num_bins_int\n              read (1, '(f30.20)', IOSTAT = EOF_marker) temp_real_array(i)\t\t! read data element from file\n              ! Debug code starts here\n              !write (*, '(a, i4)'), 'The EOF marker is ->', EOF_marker\n              !write (*, '(a, i4)') 'The counter is ->', i\n              !write (*, '(a, 30f30.20)') 'The data element was -> ', temp_real_array(i)\n              !print *\n              !print *\n              ! Debug code ends here\n          end do\n      \n          print *, 'Padding remainder of array with zeros to fill up to size of next power of 2....'\n          do i=num_bins_int+1, num_bins_int_pow2\n              temp_real_array(i) = 0.0\n              !write (*, '(a, i4)') 'The counter is ->', i\n              !write (*, '(a, 30f30.20)') 'The data element was -> ', temp_real_array(i)\n          end do\n      \n          print *, 'Exiting read_from_file_into_array procedure'\n          print *\n      end subroutine read_from_file_into_array\n        \n      subroutine compute_DFFT\n          ! *************** FFT COMPUTATION SECTION **********************\n          \n          ! Establish array of reals that is the input the FFTW3 function\n          print *, 'Entering compute_DFFT procedure'\n          print *\n          \n          in = temp_real_array\n          print *, 'num_bins_int_pow2 ->', num_bins_int_pow2\n          ! Use built in fucntion to create FFTW3 plan.  Tells FFTW3 what to do.\n          plan = fftw_plan_dft_r2c_1d((num_bins_int_pow2), in, out, FFTW_ESTIMATE)\n          !print *, 'The FFTW3 plan is ->'\n          !call fftw_print_plan(plan)\n          \n          print *\n          print *\n              \n          ! Debug code starts here\n          !print *, \"The contents of the input array is ->\"\n      ! \tdo i = 1,num_bins_int_pow2\t\t\t \n      ! \t  write (*, '(f30.20)'), in(i)\n      ! \tend do\n          ! Debug code ends here\n          \n          ! Execute FFTW3 to produce DFFT on data from file stored in array\n          print *, \"Executing DFFT on input array...\"\n          call fftw_execute_dft_r2c(plan, in, out)\n          print *, \"DFFT execution successfull\"\n          \n  \n          ! Debug code starts here\n          print *, \"The contents of the output array is ->\"\n  !     \tdo i = 1,num_bins_int_pow2\t\t\t \n  !     \t  write (*, '(f30.20, f30.20)') out(i)\n  !     \tend do\n          ! Debug code ends here\n          print *, 'Exiting compute_DFFT procedure'\n          print *\n      end subroutine compute_DFFT\n        \n      subroutine write_DFFT_to_file\n          real                    :: real_float, imag_float, corrected_frequency\n          real                    :: pi\n          !integer(kind=8)         :: real_int, imag_int\n  \n          print *, 'Entering write_DFFT_to_file procedure'\n          print *\n      \n          pi = 4*atan(1.0)\n  \n          num_samples = sample_rate * num_periods\n          write (*, '(a, i8)') 'The number of total number of samples is -> ', num_samples\n      \n          ! Traverse through output array that contains the complex DFFT, calculate magnitude and\n          ! write results to output file.  Since output is symmetric, we only want half of the output array.\n          ! The magnitude and phase will have each data element along side its corresponding corrected frequency\n          ! in two columns, separated by a space, i.e. DFFT_magnitude corrected_frequency, on each line in the output file.\n          !do i = 1, 100\n          do i = 1,(num_bins_int_pow2/2)\n          !do i = 1, (num_bins_int/2)\n  \n              ! Lines below for debug\n              !write (*, '(a, i4)'), 'The counter i is ->', i\n              !write (*, '(a, f30.20, f30.20)'), 'The DFFT data element is -> ', out(i)\n              \n              ! Obtain the real part of the complex data stored in output array as float\n              real_float = real(out(i))\n              !write (*, '(a, f30.20)'), 'The value of real_float is ->', real_float\n                  \n              ! Obtain the imaginary part of the complex data stored in output array as float\n              imag_float = aimag(out(i))\n              !write (*, '(a, f30.20)'), 'The value of imag_float is ->', imag_float\n              \n              ! Obtain the corrected frequency based on the sampe rate and the next power of two of the total number of samples (i.e. 100 samples -> next power of 2 = 128.)\n              !corrected_frequency = floor(float(i) * (float(sample_rate)/float(num_bins_int_pow2)))\n              corrected_frequency = (float(i) * (float(sample_rate)/float(num_bins_int_pow2)))\n              \n              ! Since there are num_bins_int number of data elements in FFT array, and the FFT array is symmetric, we divide the magnitude by half the num_bins_int to get the normalized magnitude.\n              magnitude = (sqrt((real_float**2) + (imag_float**2)))/float(num_bins_int/2)\n              \n              phase = (atan2(imag_float,real_float))*(180/pi)\n              !write (*, '(a, i8, a, f30.20, a, f30.5)') 'Counter -> ', i, &\n              !' Magnitude -> ', magnitude, ' Frequency -> ', corrected_frequency\n              !write (*, '(a, f30.20)'), 'The phase is -> ', phase\n              \n              !print *\n              \n              ! Write out the DFFT magnitude, a space character and the corrected frequency\n              write (10, '(f30.20, a, f30.20)', IOSTAT = good_write1) magnitude, ' ', corrected_frequency\n              \n              ! Write out the DFFT phase, a space character and the corrected frequency\n              write (20, '(f30.20, a, f30.20)', IOSTAT = good_write2) phase, ' ', corrected_frequency\n              \n              if (good_write1 .ne. 0) then\n                  !print *, 'The state of good_write1 is:'\n                  !print *, good_write1\n                  print *, 'Error writing to magnitude file!'\n                  call close_files_deallocate_and_exit(-1)\n              else if (good_write2 .ne. 0) then\n                  !print *, 'The state of good_write2 is:'\n                  !print *, good_write2\n                  print *, 'Error writing to phase file!'\n                  call close_files_deallocate_and_exit(-1)\n              end if\n  \n      end do\n  \n      ! Tell user that output file was written successfully\n      if (good_write1 .eq. 0) then\n        print *, 'Output magnitude file written successfully....'\n      endif\n      \n      if (good_write2 .eq. 0) then\n        print *, 'Output phase file written successfully....'\n      endif\n      \n      ! Deallocate memory held by plan\n      call fftw_destroy_plan(plan)\n      print *, 'Plan destroyed successfully....'\n      ! \n      ! !   The following debug code checks to see if the Inverse DFFT will produce the original input data  \n      ! !   print *, \"Output file written successfully!\"\n      ! !     \n      ! !   Swapping arrays to see if I can retrieve signal in time domain from signal in frequency domain\n      ! !   in = out\n      ! !     \n      ! !   plan = fftw_plan_dft_1d(n, in, out, FFTW_BACKWARD, FFTW_ESTIMATE)\n      ! !     \n      ! !   print *, \"The contents of the input array is ->\"\n      ! !   do i = 1,num_bins_int\n      ! !     print *, in(i)\n      ! !   end do\n      ! !     \n      ! !   print *\n      ! !     \n      ! !   print *, \"Executing DFT on input array...\"\n      ! !   call fftw_execute_dft(plan, in, out)\n      ! !     \n      ! !   print *, \"The contents of the output array is ->\"\n      ! !   do i = 1,num_bins_int\n      ! !     print *, out(i)\n      ! !   end do\n      ! !     \n      ! !   print *\n      ! !     \n      ! !   call fftw_destroy_plan(plan)\n          print *, 'Exiting write_DFFT_to_file procedure'\n          print *\n  \n    end subroutine write_DFFT_to_file\n  \n  end module MKDynamics_FFT\n  \n  program module_test\n    \n    use MKDynamics_FFT\n    implicit none\n    \n    print *, 'MKDyanmics_FFT Program Version 5.'\n  \n    call get_args\n    call open_files\n    call get_num_data_elements\n    call allocate_memory\n    call read_from_file_into_array\n    call compute_DFFT\n    call write_DFFT_to_file\n    call close_files_deallocate_and_exit(0)\n    \n    print *, 'Program completed successfully'\n    print *, 'Exiting.....'  \n  \n  end program module_test\n  \n  ","lang":"fortran","filename":"dfft_fftw3.f08","key":"IxKklBaNlu"}],"key":"AXzfC9EIeW"},{"type":"heading","depth":2,"position":{"start":{"line":135,"column":1},"end":{"line":135,"column":1}},"children":[{"type":"text","value":"Compile the Fortran 2003 Code","position":{"start":{"line":135,"column":1},"end":{"line":135,"column":1}},"key":"m1zt9fHWzJ"}],"identifier":"compile-the-fortran-2003-code","label":"Compile the Fortran 2003 Code","html_id":"compile-the-fortran-2003-code","implicit":true,"key":"PVgvOmm52D"},{"type":"paragraph","position":{"start":{"line":136,"column":1},"end":{"line":136,"column":1}},"children":[{"type":"text","value":"To compile the Fortran 2003 code, type the following command:","position":{"start":{"line":136,"column":1},"end":{"line":136,"column":1}},"key":"WuslLrIPju"}],"key":"YXVVcOc6M1"},{"type":"code","lang":"bash","value":"gfortran -o dfft_fftw3 dfft_fftw3.f08 -lfftw3","position":{"start":{"line":138,"column":1},"end":{"line":140,"column":1}},"key":"yKnEN1MdPr"},{"type":"heading","depth":2,"position":{"start":{"line":142,"column":1},"end":{"line":142,"column":1}},"children":[{"type":"text","value":"Execute the Fortran 2003 Code","position":{"start":{"line":142,"column":1},"end":{"line":142,"column":1}},"key":"LcHpoehQ5K"}],"identifier":"execute-the-fortran-2003-code","label":"Execute the Fortran 2003 Code","html_id":"execute-the-fortran-2003-code","implicit":true,"key":"Y5HNE1TzRW"},{"type":"paragraph","position":{"start":{"line":143,"column":1},"end":{"line":143,"column":1}},"children":[{"type":"text","value":"To execute the Fortran 2003 code, type the following command:","position":{"start":{"line":143,"column":1},"end":{"line":143,"column":1}},"key":"UlcwiTVjFh"}],"key":"rnCi2IuYnq"},{"type":"code","lang":"bash","value":"./dfft_fftw3 outfile.dat DFFT_mag_file.dat DFFT_phase_file.dat","position":{"start":{"line":145,"column":1},"end":{"line":147,"column":1}},"key":"SWSMoriDnf"},{"type":"paragraph","position":{"start":{"line":149,"column":1},"end":{"line":150,"column":1}},"children":[{"type":"text","value":"where outfile.dat is the output of the Python script, DFFT_mag_file.dat is the DFFT magnitude\nDFFT_phase_file.dat is the DFFT phase (if applicable).","position":{"start":{"line":149,"column":1},"end":{"line":149,"column":1}},"key":"jE295NEoKZ"}],"key":"TWS7cMhU30"},{"type":"heading","depth":2,"position":{"start":{"line":152,"column":1},"end":{"line":152,"column":1}},"children":[{"type":"text","value":"Visualize the DFFT Results","position":{"start":{"line":152,"column":1},"end":{"line":152,"column":1}},"key":"n5mZv5oMoJ"}],"identifier":"visualize-the-dfft-results","label":"Visualize the DFFT Results","html_id":"visualize-the-dfft-results","implicit":true,"key":"kPESAM55JF"},{"type":"paragraph","position":{"start":{"line":153,"column":1},"end":{"line":153,"column":1}},"children":[{"type":"text","value":"The DFFT results are visualized using GNUPlot.  The GNUPlot script is as follows:","position":{"start":{"line":153,"column":1},"end":{"line":153,"column":1}},"key":"rDrKMP8jGo"}],"key":"TCTHef347v"},{"type":"code","lang":"bash","value":"set term wxt 0\nset xrange [0:50]\nset title \"DFFT Magnitude of 10Hz Sine Wave\"\nset xlabel \"Frequency [Hz]\"\nset ylabel \"Arbitrary Units [Arb]\"\nplot \"DFFT_mag_file.dat\" using 1 with lines\n\nset term wxt 1\nset xrange [0:50]\nset title \"DFFT Phase of 10Hz Sine Wave\"\nset xlabel \"Frequency [Hz]\"\nset ylabel \"Phase [degrees]\"\nplot \"DFFT_phase_file.dat\" using 1 with lines","position":{"start":{"line":155,"column":1},"end":{"line":169,"column":1}},"key":"iMYe2FSDcm"},{"type":"paragraph","position":{"start":{"line":171,"column":1},"end":{"line":171,"column":1}},"children":[{"type":"text","value":"To execute the GNUPlot script, type the following command:","position":{"start":{"line":171,"column":1},"end":{"line":171,"column":1}},"key":"Zvs9XPkYvV"}],"key":"SMvBQPuxWX"},{"type":"code","lang":"bash","value":"gnuplot -persist plot_dfft.gnu","position":{"start":{"line":173,"column":1},"end":{"line":175,"column":1}},"key":"Kga0LrSibh"},{"type":"paragraph","position":{"start":{"line":176,"column":1},"end":{"line":176,"column":1}},"children":[{"type":"text","value":"or start GNUPlot and type the following to load the script:","position":{"start":{"line":176,"column":1},"end":{"line":176,"column":1}},"key":"u968e2vcll"}],"key":"WruYBDpApG"},{"type":"code","lang":"bash","value":"load 'plot_dfft.gnu'","position":{"start":{"line":178,"column":1},"end":{"line":180,"column":1}},"key":"mMHbYWsqu4"},{"type":"heading","depth":2,"position":{"start":{"line":182,"column":1},"end":{"line":182,"column":1}},"children":[{"type":"text","value":"Results","position":{"start":{"line":182,"column":1},"end":{"line":182,"column":1}},"key":"ZfbN9hxePm"}],"identifier":"results","label":"Results","html_id":"results","implicit":true,"key":"LRQL1YNTeU"},{"type":"paragraph","position":{"start":{"line":185,"column":1},"end":{"line":185,"column":1}},"children":[{"type":"text","value":"The magnitude and phase plots are shown below:","position":{"start":{"line":185,"column":1},"end":{"line":185,"column":1}},"key":"AwMGOTz3io"}],"key":"nycD5UWGl4"},{"type":"heading","depth":3,"position":{"start":{"line":187,"column":1},"end":{"line":187,"column":1}},"children":[{"type":"text","value":"DFFT Magnitude Plot","position":{"start":{"line":187,"column":1},"end":{"line":187,"column":1}},"key":"bfigJsDbrZ"}],"identifier":"dfft-magnitude-plot","label":"DFFT Magnitude Plot","html_id":"dfft-magnitude-plot","implicit":true,"key":"m6pVlG5XBW"},{"type":"image","url":"/build/DFFT_mag_sine_wave2_-c0eb2afb5edf9273640dc6c23b3fd3f6.jpeg","align":"center","key":"KhdNzRzs7A","urlSource":"images/DFFT_mag_sine_wave2_10Hz.jpeg","urlOptimized":"/build/DFFT_mag_sine_wave2_-c0eb2afb5edf9273640dc6c23b3fd3f6.webp"},{"type":"heading","depth":3,"position":{"start":{"line":193,"column":1},"end":{"line":193,"column":1}},"children":[{"type":"text","value":"DFFT Phase Plot","position":{"start":{"line":193,"column":1},"end":{"line":193,"column":1}},"key":"eBW0U0bjhT"}],"identifier":"dfft-phase-plot","label":"DFFT Phase Plot","html_id":"dfft-phase-plot","implicit":true,"key":"kNszoBXup5"},{"type":"image","url":"/build/DFFT_phase_sine_wave-77f1b3befc70889daa3dfc54dc6a4df4.jpeg","align":"center","key":"IJIsqzdH5k","urlSource":"images/DFFT_phase_sine_wave2_10Hz.jpeg","urlOptimized":"/build/DFFT_phase_sine_wave-77f1b3befc70889daa3dfc54dc6a4df4.webp"},{"type":"heading","depth":2,"position":{"start":{"line":199,"column":1},"end":{"line":199,"column":1}},"children":[{"type":"text","value":"Discussion","position":{"start":{"line":199,"column":1},"end":{"line":199,"column":1}},"key":"K4QReoSqja"}],"identifier":"discussion","label":"Discussion","html_id":"discussion","implicit":true,"key":"nsADrKJQoO"},{"type":"paragraph","position":{"start":{"line":200,"column":1},"end":{"line":200,"column":1}},"children":[{"type":"text","value":"The DFFT of the sine wave at 10 Hz was successfully computed using the FFTW3 library in Fortran. The results were visualized using GNUPlot. The magnitude and phase plots are shown above.","position":{"start":{"line":200,"column":1},"end":{"line":200,"column":1}},"key":"QJFmYFry6S"}],"key":"JbIKcVrLG0"},{"type":"paragraph","position":{"start":{"line":202,"column":1},"end":{"line":204,"column":1}},"children":[{"type":"text","value":"The phase plot above displays overall quantization noise and computation noise of FFTW3, since\npure frequency sine wave with zero phase should have been a straight line at 0 degrees.\nThis plot gives a feel for the accuracy of the computational engine.","position":{"start":{"line":202,"column":1},"end":{"line":202,"column":1}},"key":"CFjZuNwbgJ"}],"key":"qFcjbYFVOf"},{"type":"paragraph","position":{"start":{"line":206,"column":1},"end":{"line":208,"column":1}},"children":[{"type":"text","value":"There appears to be good correlation between the DFFT magnitude plot generated by SciLAB and\nthe DFFT magnitude plot generated by the Fortran 2003 code. Of note are is the anomalous\nphase results in the output of the Fortran 2003 code. It is unknown at this time what is causing it.  It would be interesting to see the results on a signal with known phase shift.","position":{"start":{"line":206,"column":1},"end":{"line":206,"column":1}},"key":"TfTxkUUwlW"}],"key":"bDvAHK1BdB"},{"type":"heading","depth":2,"position":{"start":{"line":210,"column":1},"end":{"line":210,"column":1}},"children":[{"type":"text","value":"Conclusion","position":{"start":{"line":210,"column":1},"end":{"line":210,"column":1}},"key":"HnS1YiLs9H"}],"identifier":"conclusion","label":"Conclusion","html_id":"conclusion","implicit":true,"key":"GZbT8eAukJ"},{"type":"paragraph","position":{"start":{"line":211,"column":1},"end":{"line":211,"column":1}},"children":[{"type":"text","value":"The Discretized Fourier Transform of a sine wave at 10 Hz was successfully computed using the FFTW3 library in Fortran. The results were visualized using GNUPlot. The magnitude and phase plots are shown above.","position":{"start":{"line":211,"column":1},"end":{"line":211,"column":1}},"key":"pDUgjFYRGC"}],"key":"fMjQM9G8lj"}],"key":"iRTpUFZRx1"}],"key":"k4qSSvT94w"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Discretized Fourier Transform of Arbitrary Signal Using FFTW3 in Fortran","url":"/sections/computer-programming/fortran/dfft/dfft-head","group":"Computer Programming"},"next":{"title":"Square Wave at 1Hz","url":"/sections/computer-programming/fortran/dfft/square-wave-1-hz-50-pct/square-wave-1-hz-50-pct","group":"Computer Programming"}}},"domain":"http://localhost:3009"}