

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>MK Dynamics &#8212; MK Dynamics</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=5b4479735964841361fd" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=5b4479735964841361fd" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=5b4479735964841361fd" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=5b4479735964841361fd" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" href="../../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=5b4479735964841361fd" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=5b4479735964841361fd" />
  <script src="../../../_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=5b4479735964841361fd"></script>

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'Sections/Cybersecurity/Basic_Linux_Exploits/basic_linux_exploits';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Notebooks with MyST Markdown" href="../../../markdown-notebooks.html" />
    <link rel="prev" title="LiveOverflow" href="../LiveOverflow/liveoverflow.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/spacey.jpg" class="logo__image only-light" alt="MK Dynamics - Home"/>
    <script>document.write(`<img src="../../../_static/spacey.jpg" class="logo__image only-dark" alt="MK Dynamics - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../../intro.html">
                    Main Page
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Cybersecurity</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active has-children"><a class="reference internal" href="../cybersecurity.html">Cybersecurity</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2 has-children"><a class="reference internal" href="../Protostar/protostar.html">Protostar Exploit Exercises</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../Protostar/Stack0/stack0.html">Stack 0</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../Protostar/Stack0/stack0_x86.html">MK Dynamics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../LiveOverflow/liveoverflow.html">LiveOverflow</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">MK Dynamics</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Misc</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../markdown-notebooks.html">Notebooks with MyST Markdown</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks.html">Content with notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../README.html">MKDynamics_Website_V2</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/markkhusid/MKDynamics_Website_V2" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/markkhusid/MKDynamics_Website_V2/issues/new?title=Issue%20on%20page%20%2FSections/Cybersecurity/Basic_Linux_Exploits/basic_linux_exploits.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../_sources/Sections/Cybersecurity/Basic_Linux_Exploits/basic_linux_exploits.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>MK Dynamics</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#computer-security-basic-linux-exploits">Computer Security - Basic Linux Exploits</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">Introduction</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction-to-buffer-overflows-and-preparing-a-32-bit-ubuntu-virtual-machine">Introduction to Buffer Overflows and Preparing a 32-bit Ubuntu Virtual Machine</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#brief-synopsis-of-meet-c">Brief synopsis of meet.c</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#disabling-address-space-layout-randomization-aslr">Disabling Address Space Layout Randomization (ASLR)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#smashing-the-stack-of-a-vulnerable-program-and-causing-a-buffer-overflow-overflowing-the-buffer-of-the-vulnerable-program-meet-c">Smashing the Stack of a Vulnerable Program and Causing a Buffer Overflow - Overflowing the Buffer of the Vulnerable Program meet.c</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compiling-meet-c-with-nx-disabled-with-debugging-information-and-static-compilation">Compiling meet.c with NX disabled, with debugging information and static compilation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#running-the-executable-meet-normally">Running the executable <em>meet</em> normally</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fuzzing-the-inputs-to-the-executable-meet">Fuzzing the inputs to the executable <em>meet</em></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#inserting-shellcode-into-a-vulnerable-processs-from-the-command-line-to-obtain-a-command-shell">Inserting Shellcode into a Vulnerable Processs from the Command Line to Obtain a Command Shell</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#breaking-down-the-attack-string-in-detail">Breaking Down the Attack String in Detail</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#use-of-the-cmd-cmd-cmd-cmd-format">Use of the “$(<em>cmd</em>; <em>cmd</em>; <em>cmd</em>; <em>cmd</em>)” format</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#using-to-craft-an-attack-string">Using “$()” to craft an attack string</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#putting-it-all-together">Putting it all together</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#discovering-the-memory-address-of-the-buffer-we-wish-to-overflow">Discovering the memory address of the buffer we wish to overflow</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#calculating-how-many-bytes-we-need-to-inject-into-the-vulnerable-buffer-to-overwrite-the-instruction-pointer-eip">Calculating how many bytes we need to inject into the vulnerable buffer to overwrite the instruction pointer EIP.</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#state-of-execution-just-before-the-saved-eip-is-popped-off-of-the-stack-and-execution-is-supposed-to-return-back-to-the-main-function-in-the-executable-meet-according-to-the-gef-ui-for-gdb">State of execution just before the saved EIP is popped off of the stack, and execution is supposed to return back to the main function in the executable <em>meet</em>, according to the GEF UI for GDB.</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#discovering-the-memory-address-of-the-stack">Discovering the memory address of the stack</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#variations-in-the-top-of-the-stack-with-multiple-attack-attempts-from-the-command-line">Variations in the top of the stack with multiple attack attempts from the command line</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Discovering the memory address of the stack</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-small-program-that-displays-the-current-state-of-the-stack-pointer">A small program that displays the current state of the stack pointer</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lorem">Lorem</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">Lorem</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">Lorem</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">Lorem</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">Lorem</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">Lorem</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">Lorem</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">Lorem</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">Lorem</a></li>
</ul>
</li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="mk-dynamics">
<h1>MK Dynamics<a class="headerlink" href="#mk-dynamics" title="Permalink to this heading">#</a></h1>
<section id="computer-security-basic-linux-exploits">
<h2>Computer Security - Basic Linux Exploits<a class="headerlink" href="#computer-security-basic-linux-exploits" title="Permalink to this heading">#</a></h2>
<section id="introduction">
<h3>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">#</a></h3>
<p>This section will borrow heavily from “Gray Hat Hacking, The Ethical Hacker’s Handbook”, by Regaldo, et. al, McGraw Hill, 4th. Edition.<br />
<a class="reference external" href="https://www.amazon.com/Hacking-Ethical-Hackers-Handbook-Fourth/dp/0071832386/ref=sr_1_2?ie=UTF8&amp;qid=1540671368&amp;sr=8-2&amp;keywords=gray+hat+hacking">Gray Hat Hacking (Amazon)</a></p>
<p>Note that there is a 5th Edition available at the time of this writing.</p>
<p>We will also make use of the classic discussion on Buffer Overflows by Aleph One.<br />
<a class="reference external" href="https://insecure.org/stf/smashstack.html">Aleph One’s Classic on Buffer Overflows.</a></p>
<p>We will also use tips and tricks from the following:</p>
<p>Open Security Training’s course on Introduction to Exploits 1<br />
<a class="reference external" href="http://www.opensecuritytraining.info/">Open Security Training</a></p>
<p>“The Shellcoder’s Handboook”, by Anley et. al, Wiley, 2nd Edition<br />
<a class="reference external" href="https://www.amazon.com/Shellcoders-Handbook-Discovering-Exploiting-Security/dp/047008023X/ref=sr_1_2?ie=UTF8&amp;qid=1540671203&amp;sr=8-2&amp;keywords=the+shellcoders+handbook">The Shellcoder’s Handbook (Amazon)</a></p>
<p>In this section, we will discuss trying to inject shellcode into a vulnerable program from the command line, investigate errors, and perform debugging of these errors with the Gnu DeBugger (GDB).</p>
<p>Smashing the Stack of a Vulnerable Program and Causing a Buffer Overflow</p>
</section>
<section id="introduction-to-buffer-overflows-and-preparing-a-32-bit-ubuntu-virtual-machine">
<h3>Introduction to Buffer Overflows and Preparing a 32-bit Ubuntu Virtual Machine<a class="headerlink" href="#introduction-to-buffer-overflows-and-preparing-a-32-bit-ubuntu-virtual-machine" title="Permalink to this heading">#</a></h3>
<p>The following image was taken from the following presentation:</p>
<p>Stack-Based Buffer Overflows Attacker<br />
By: Laurence Davis<br />
<a class="reference external" href="https://slideplayer.com/slide/4775349/">Stack-Based Buffer Overflows</a></p>
<p><img alt="" src="../../../_images/buffer_overflow_image.jpeg" /></p>
<p>Buffer overflow corrupting return address on the stack</p>
<p>By overfilling the function’s local variables with data, one is able to overwrite the saved EIP (return pointer in the figure). This is a vulnerability in the way the kernel and C compiler handles function calls, because shellcode can be inserted onto the stack and the saved return address may be overwritten to point to the shellcode. However, as seen in the section on Shellcoding, modern kernels will not allow execution of data on the stack. So even though this vulnerability has for the most part been patched, we will still learn it because fundamentally, it is the basis for many such vulnerabilities, found even in modern kernels.</p>
<p>We will now investigate exploiting this vulnerability with a simple vulnerable C test program called <em>meet.c</em> shown below.</p>
<p>The vulnerable C program: meet.c</p>
<p><a class="reference download internal" download="" href="../../../_downloads/43f936978eed5af25f2bcad86ad3aef8/meet.c"><span class="xref download myst">Click here to download meet.c</span></a></p>
</section>
<section id="brief-synopsis-of-meet-c">
<h3>Brief synopsis of meet.c<a class="headerlink" href="#brief-synopsis-of-meet-c" title="Permalink to this heading">#</a></h3>
<p>In the program <em>meet.c</em>, we include string.h in order to make use of the vulnerable strcpy command. The format of the strcpy command is as follows:</p>
<blockquote>
<div><p>char *strcpy(char *dest, const char *src);</p>
</div></blockquote>
<p>From the man page for strcpy:</p>
<blockquote>
<div><p><em>The strcpy() function copies the string pointed to by src, including the terminating null byte (‘\0’), to the buffer pointed to by dest. The strings may not overlap, and the destination string dest must be large enough to receive the copy. Beware of buffer overruns!</em></p>
</div></blockquote>
<p>The program’s main function reads in two arguments, which are stored in the argv array of strings. They are argv[1] and argv[2] for the first and second arguments, respectively.</p>
<p>The main function calls a function called <em>greeting</em>. Greeting has a local variable that is 400 bytes long called <em>name</em>. This local variable acts like an input buffer. In order to aid in understanding the memory layout of this program, I have added three diagnostic statements that print out the memory addresses of the local variable <em>name</em>, as well as the two function arguments, <em>temp1</em> and <em>temp2.</em></p>
<p>Now this is where things get interesting. For educational purposes, the VERY vulnerable <em>strcpy</em> function is called from within the function called <em>greeting</em>. What <em>strcpy</em> will do is to copy the argument <em>temp2</em> into the buffer <em>name</em>, WITHOUT any bounds checking. This means that if the argument <em>temp2</em> is carefully crafted, the buffer <em>name</em> can be overflowed. When it is overflowed, it will overwrite adjacent data, which includes the return address to the calling function main!</p>
<p>Normally used, the function called <em>greeting</em> then prints out the string Hello, followed by the first argument, and the contents of the buffer called <em>name</em>. Control is then returned back to the main function, which prints out the string, Bye, followed by the first and second arguments from the command line. We will now investigate attacking the aforementioned built-in vulnerability in this program. But first, we must set up the environment.</p>
</section>
<section id="disabling-address-space-layout-randomization-aslr">
<h3>Disabling Address Space Layout Randomization (ASLR)<a class="headerlink" href="#disabling-address-space-layout-randomization-aslr" title="Permalink to this heading">#</a></h3>
<p>As mentioned previously, modern Linux kernels use several strategies to overcome vulnerabilities such as buffer overflows. One of these strategies is known as Address Space Layout Randomization (ASLR). Essentially, the kernel randomizes the process’s address space, which includes the stack, thereby precluding the ability to brute force overwriting of the stored return address on the stack. Every attempt will require injection of a new malicious address that points back to the shellcode. This is extremely difficult to guess, if not impossible.</p>
<p>Another strategy is to simply not allow execution of data on the stack. Since the buffer and hence the injected shellcode resides entirely on the stack, execution of the shellcode will not be allowed by the kernel, and the process will crash.</p>
<p>To get around such protections, for pedagogical reasons, we will disable both ASLR and allow execution of data on the stack. This will require either recompiling the C program with executable stack or enabling executable stack at the kernel level. In order to disable ASLR, a bash shell may be opened with the following command:</p>
<blockquote>
<div><p>$ setarch i386 -R /bin/bash</p>
</div></blockquote>
<p>or by disabling ASLR at the kernel level. To minimize variables, it is better to do this at the kernel level; however, this is not a good idea on your main system for security reasons. Therefore, we will spin up a 32-bit Ubuntu virtual machine and disable these protections at the kernel level, as shown in the image below:</p>
<p><img alt="" src="../../../_images/setting_up_32bit_vm.jpg" /></p>
<p>Disabling ASLR in the 32-bit Ubuntu Virtual Machine</p>
<p>As can be seen from the screenshot above, it is not directly possible to disable non-executable stack or data execution protections, also called NX. This must be done at the UEFI or BIOS level. It is however, possible to disable ASLR by using the command:</p>
<blockquote>
<div><p>$ echo “0”&gt; /proc/sys/kernel/randomize_va_space</p>
</div></blockquote>
<p>In order test that the process’ address space is not randomized, we issue the following command a few times and observe that the address space is constant between issuing the command:</p>
<blockquote>
<div><p>$ cat /proc/self/maps<br />
[…. memory layout table ….]</p>
<p>$ cat /proc/self/maps<br />
[…. unchanged memory layout table ….]</p>
<p>$ cat /proc/self/maps<br />
[…. unchanged memory layout table ….]</p>
</div></blockquote>
<p>The following screenshot shows these commands in the 32-bit Ubuntu VM:</p>
<p><img alt="" src="../../../_images/VM_mem_map_info_ASLR_off.jpg" /></p>
<p>Process memory map showing no randomization of address space layout</p>
<p>As can be seen from the above screenshot, the address space layout is not randomized. Each invocation of the cat /proc/self/maps command produces the same results. Of particular interest is that the stack’s address remains constant at:</p>
<blockquote>
<div><p>bffdf000-c0000000 rw-p 00000000 00:00 0 [stack]</p>
</div></blockquote>
<p>Notice that the stack has permissions of rw, but not exectute.</p>
<p>In order to overcome the inability to disable non-executable (NX) stack or data segments at the kernel level, we will have to remember to issue special directives to the compiler when compiling vulnerable programs. These compiler directives are:</p>
<blockquote>
<div><p>gcc …<em>-zexecstack -fno-stack-protector</em>…</p>
</div></blockquote>
<p>The directive <em>-zexecstack</em> tells the compiler to enable an executable stack, while the directive <em>-fno-stack-protector</em> tells the compiler to disable stack corruption protections.</p>
<p>We are now ready to attempt to overflow the buffer of the vulnerable program from the command line.</p>
</section>
</section>
<section id="smashing-the-stack-of-a-vulnerable-program-and-causing-a-buffer-overflow-overflowing-the-buffer-of-the-vulnerable-program-meet-c">
<h2>Smashing the Stack of a Vulnerable Program and Causing a Buffer Overflow - Overflowing the Buffer of the Vulnerable Program meet.c<a class="headerlink" href="#smashing-the-stack-of-a-vulnerable-program-and-causing-a-buffer-overflow-overflowing-the-buffer-of-the-vulnerable-program-meet-c" title="Permalink to this heading">#</a></h2>
<section id="compiling-meet-c-with-nx-disabled-with-debugging-information-and-static-compilation">
<h3>Compiling meet.c with NX disabled, with debugging information and static compilation<a class="headerlink" href="#compiling-meet-c-with-nx-disabled-with-debugging-information-and-static-compilation" title="Permalink to this heading">#</a></h3>
<p>As described in the previous section, it is first necessary to compile meet.c with executable stack protections off. We will also include lots of debugging information, and we will compile the program with the <em>-static</em> flag, so that all of the called system libraries will be included in the executable. Having all of the called system libraries included tends to aid debugging, since the GNU Debugger (GDB) will not have to jump around memory as much. Finally, we will force 32-bit compilation. Since we will be running the executable on a 32-bit Virtual Machine (VM), this might be a moot point, but we will do it anyway to minimize differences in executable operation among different systems.</p>
<p>To compile meet.c, we issue the following command:</p>
<blockquote>
<div><p>$ gcc -m32 -static -ggdb3 -zexecstack -fno-stack-protector -mpreferred-stack-boundary=2 meet.c -o meet</p>
</div></blockquote>
<p>The results of this command are shown in the image below:</p>
<p><img alt="" src="../../../_images/compiling_meet_c_in_VM.jpg" /></p>
<p>Compiling meet.c statically, with NX disabled and extensive debugging information</p>
<p>The command we used to compile meet.c had the following arguments:</p>
<p>Argument</p>
<p>Meaning</p>
<p>-m32</p>
<p>Compile into 32-bit mode.</p>
<p>-static</p>
<p>Compile the program statically, with all libraries included within the executable.</p>
<p>-ggdb3</p>
<p>Include maximum debugging information.</p>
<p>-zexecstack</p>
<p>Allow an executable stack. Basically one part in overiding NX.</p>
<p>-fno-stack-protector</p>
<p>Disable stack corruption protections. Second part in overiding NX.</p>
<p>-mpreferred-stack-boundary=2</p>
<p>Sets the size of each entry in the stack to 2^2=4 bytes long. This makes it easier four our data alignment purposes, since we will be dealing with 32-bit or 4 byte memory locations.</p>
</section>
<section id="running-the-executable-meet-normally">
<h3>Running the executable <em>meet</em> normally<a class="headerlink" href="#running-the-executable-meet-normally" title="Permalink to this heading">#</a></h3>
<p>We run the program <em>meet</em> normally with the arguments Mr Mark as follows:</p>
<blockquote>
<div><p>$ ./meet Mr Mark</p>
</div></blockquote>
<p>After issuing the command, we get the following output:</p>
<p><img alt="" src="../../../_images/running_meet_normally.jpg" /></p>
<p>Running the executable meet normally with the arguments Mr Mark</p>
<p>As can be seen from the above screen capture, the program prints out the memory addresses of the buffer we will overflow, which is the 400 byte buffer called <em>name</em>. It also prints out the memory addresses of the two arguments, <em>temp1</em> and <em>temp2</em>. The astute observer will notice that these addresses are actually within the stack segment! Notice also that <em>temp2</em> is exactly 4 bytes away from <em>temp1.</em></p>
<p>The program then prints out the string Hello, followed by the program arguments. Finally, the program prints out the string Bye, followed by the program arguments.</p>
</section>
<section id="fuzzing-the-inputs-to-the-executable-meet">
<h3>Fuzzing the inputs to the executable <em>meet</em><a class="headerlink" href="#fuzzing-the-inputs-to-the-executable-meet" title="Permalink to this heading">#</a></h3>
<p>To find the size of the buffer, we will increase the number of bytes input into the second argument until the program begins to crash. Actually, we could have tried the first argument, but we would have found that the first argument is very resilient, since it is not actually taking part in the vulnerable strcpy command. This could have been surmised from reverse engineering the binary, if the source code was not available. Below we show what happens even when we inject 500 “A“‘s into the first argument. In the second image, we will attempt to insert 2000 “A“‘s and see what happens.</p>
<p><img alt="" src="../../../_images/fuzzing_first_arg_to_meet_c.jpg" /></p>
<p>Attempt at fuzzing first argument with 500 “A“‘s into the executable <em>meet</em></p>
<p>In the figure above, we first try 10 “A“‘s and then 500 “A“‘s, and nothing seems to break. Again, this is because only the second argument participates in the vulnerable strcpy command. To make absolutely sure, in the figure below, we inject 2000 “A“‘s into the first argument of the executable <em>meet</em>.</p>
<p><img alt="" src="../../../_images/fuzzing_first_arg_to_meet_c_with_2000_A.jpg" /></p>
<p>Attempt at fuzzing first argument with 2000 “A“‘s into the executable <em>meet</em></p>
<p>In the figure above, nothing seems to break. We therefore focus on the second argument. Our goal is to find the size of the vulnerable buffer, so we start low and work our way up until we encounter a segmentation fault. This fault will indicate that our input has overwritten the return address of the the main function within the executable <em>meet</em>.</p>
<p><img alt="" src="../../../_images/fuzzing_second_arg_to_meet_c.jpg" /></p>
<p>Attempt at fuzzing the second argument with an increasing number of “A“‘s into the executable <em>meet</em></p>
<p>Still no segmentation faults. We continue increasing the number of “A“‘s in the figure below.</p>
<p><img alt="" src="../../../_images/fuzzing_second_arg_to_meet_c_to_get_seg_fault.jpg" /></p>
<p>Segmentation fault found!</p>
<p>We can see that we have found the segmentation fault after injecting 400 “A“‘s into the second argument. 398 and 399 did not do it. From this we can surmise that the first argument “Mr” took two bytes and the second argument took 400 bytes, and this was enough to overwrite the main function’s return address. Since the saved base pointer took four bytes and the saved return address took an additional four bytes, we have probably overwritten the saved base pointer, at which the main function used this corrupted base pointer for its stack frame operations. But since we have corrupted the saved base pointer, the program tried to access an invalid part of memory, and hence we obtained the segmentation fault.</p>
<p>From this we can surmise that the vulnerable buffer size is about 400 bytes. Let us fire up the Gnu DeBugger on the segmentation fault and see what happened. Before we do this, we install the PEDA extension for GDB to make life easier. This can be found at:<br />
<a class="reference external" href="https://github.com/longld/peda">Python Exploit Development Assistance</a></p>
<p><img alt="" src="../../../_images/finding_assembly_inst_that_caused_seg_fault.jpg" /></p>
<p>Finding root cause of the segmentation fault</p>
<p>We can see from GDB that the exact instruction that caused the segmentation fault was found at the address main+35:</p>
<p>The instruction attempted to load into EDX the contents of the memory address pointed to by EAX. We can observe that the contents of the registers was:</p>
<p>Looking specifically at EAX, it contained 0x41414149. 0x41 is the ASCII code for the capital A. We can see that when the CPU tried to access the contents of the memory location pointed to by EAX, we got the segmentation fault. This is because the memory address 0x41414149 is outside of the program’s allowable access segments.</p>
<p>What appears to have happened is that the return address was not overwritten, because the program was able to return to main. However, it appears that argc and argv where overwritten by the buffer overflow. Recall that argc contains the number of arguments, including the command itself. In our case, argc would have been 2, since it starts at 0.</p>
<p>argv[ ] is an array of strings. Each string in argv are the arguments, where argv[0] is the command itself. In our case, argv[1] would have been “Mr” and argv[2] would have been 400 “A“‘s. What we are really after is to overwrite EIP. To do that, we will have to add an additional 8 “A”s, which equals a total of 8 bytes. 4 of those bytes will overwrite the saved EBP, and the other 4 bytes will overwrite the saved EIP. We show the results of running <em>meet</em> with 408 “A“‘s for the second argument in the screen shot below:</p>
<p><img alt="" src="../../../_images/fuzzing_second_arg_to_meet_to_overwrite_EIP.jpg" /></p>
<p>Overwriting EIP by injecting 408 “A“‘s into the second argument to the executable <em>meet</em></p>
<p>Now that we have found a way to overwrite EIP, we can basically get the processor to execute arbitrary code within the processes memory segment. If we could insert shellcode into the second argument, and then overwrite the return address to point to the start of the shellcode, then we will cause the process to spawn a shell. If this process was running under root privileges, then the shell will be a root shell, where we can basically control the entire system. Let us try to do this from the command line.</p>
</section>
</section>
<section id="inserting-shellcode-into-a-vulnerable-processs-from-the-command-line-to-obtain-a-command-shell">
<h2>Inserting Shellcode into a Vulnerable Processs from the Command Line to Obtain a Command Shell<a class="headerlink" href="#inserting-shellcode-into-a-vulnerable-processs-from-the-command-line-to-obtain-a-command-shell" title="Permalink to this heading">#</a></h2>
<p>In this section, our goal is to try to insert shellcode into the vulnerable executable <em>meet</em>. We will then do the same thing in GDB to see exactly what happens.</p>
<p>We will approah this section by showing a successful attack of a vulnerable program from the command line, and then dissect every aspect of how this was achieved. In order to show how dramatic such an attack can be, we will escalate the privileges of the vulnerable program to that of super user (SUID). This will cause the vulnerable program to drop out of normal execution and into a command shell with root privileges.</p>
<p><img alt="" src="../../../_images/changing_meet_to_suid.jpg" /></p>
<p>Changing the execution privileges of the executable <em>meet</em> to SUID</p>
<p>By issuing the command:</p>
<blockquote>
<div><p>$ sudo chmod u+s meet</p>
</div></blockquote>
<p>we give the executable <em>meet</em> the privileges to execute at the root level.</p>
<p><strong>NOTE! DO NOT LEAVE A VULNERABLE EXECUTABLE WITH SUID ROOT PRIVILEGES ON YOUR SYSTEM AFTER YOU ARE DONE!</strong></p>
<p>We then inject our attack payload into the second parameter, because as discussed previously, the first parameter is not vulnerable to this attack. The attack and results are shown below:</p>
<p><img alt="" src="../../../_images/cmd_line_sc_injection_root_shell.jpg" /></p>
<p>Injecting payload into the vulnerable parameter of the executable <em>meet</em> to obtain a root shell</p>
<p>SUCCESS!</p>
<p>By issuing the command:</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\( sudo ./meet mr &quot;\)</span>(perl -e ‘print “\x90”x200’; cat sc; perl -e ‘print “\x90”x27’ ;perl -e ‘print “\x18\xf2\xff\xbf”x38’)”</p>
</div></blockquote>
<p>we were able to overflow a buffer within the executable <em>meet</em>, and overwrite the return address. By doing so, we hijacked the instruction pointer EIP to execute our arbitrary code. In this case, our arbitrary code was shellcode, which provides a command shell. Since the executable <em>meet</em> ran at the root privilege level, once the shell is spawned, any command entered runs at the root privilege level.</p>
<p>We will now break down the attack string in great detail.</p>
</section>
<hr class="docutils" />
<section id="breaking-down-the-attack-string-in-detail">
<h2>Breaking Down the Attack String in Detail<a class="headerlink" href="#breaking-down-the-attack-string-in-detail" title="Permalink to this heading">#</a></h2>
<section id="use-of-the-cmd-cmd-cmd-cmd-format">
<h3>Use of the “$(<em>cmd</em>; <em>cmd</em>; <em>cmd</em>; <em>cmd</em>)” format<a class="headerlink" href="#use-of-the-cmd-cmd-cmd-cmd-format" title="Permalink to this heading">#</a></h3>
<p>The attack string used the format:</p>
<blockquote>
<div><p>“$(<em>cmd</em>; <em>cmd</em>; <em>cmd</em>; <em>cmd</em>)”</p>
</div></blockquote>
<p>The shell command format <span class="math notranslate nohighlight">\(() replaces the unweildy backtick &quot; \` &quot; format, making an entered command much easier to read and understand. Individual commands within the parentheses can be separated by a semicolon. The quotation marks on the outside, i.e. &quot;\)</span>()” tell the command shell to treat everything within the quotes as a literal string. See below for examples:</p>
<p><img alt="" src="../../../_images/using_quotes_on_command_line.jpg" /></p>
<p>Demonstration of the effect of quotation marks at the Linux command prompt</p>
<p>As can be seen from the above screen shot, putting separated commands into quotes causes everything contained within the quotes to be treated as a single string. This is a good property for injecting shellcode from the command line into a vulnerable executable.</p>
<p>We will now examine using <span class="math notranslate nohighlight">\(() and &quot;\)</span>()” on the command line.</p>
<p><img alt="" src="../../../_images/using_dollar_paranthesis_on_command_line.jpg" /></p>
<p>Using <span class="math notranslate nohighlight">\(() and &quot;\)</span>()” on command line</p>
<p>As can be seen from the screenshot above, putting commands separated by a semicolon within $(), causes the the output of the commands to be substituted into their place and the output to be executed by the shell. In the case of the first command <em>date</em>, the output is Sun, for Sunday, and the shell tries to execute Sun, but this is not a valid Linux command, so the command shell throws an error.</p>
<p>Alternatively, putting multiple commands separated by a semicolon within “$()” causes all of the commands to be executed, and the outputs of all of the commands are substituted in, wherein the shell tries to execute the outputs as if they were an actual shell command. That is why the shell returns an error in the screenshot above.</p>
<p>We will now put these concepts together to craft an attack string.</p>
</section>
<section id="using-to-craft-an-attack-string">
<h3>Using “$()” to craft an attack string<a class="headerlink" href="#using-to-craft-an-attack-string" title="Permalink to this heading">#</a></h3>
<p>We begin by using two shell commands:</p>
<blockquote>
<div><p>perl -e ‘<em>perl command</em>’</p>
<p>xxd <em>filename</em></p>
</div></blockquote>
<p>These commands can be broken down as follows:</p>
<p>Command</p>
<p>Meaning</p>
<p>perl -e ‘<em>perl command</em>’</p>
<p>Execute perl command contained within the single quotes</p>
<p>xxd <em>filename</em></p>
<p>Creates a hex dump of a given file or standard input.</p>
<p>We will craft an attack string using perl commands and pipe the output of the attack string into xxd, to see whether the hexadecimal values align properly in memory and do not contain any bad characters, such a null byte, i.e. \x00, or the linefeed character, i.e. \x0a. The null byte is bad because many string processing functions in C interpret the null byte as the end of the string. So if our attack string contains a null byte in the middle of it, then only a portion of the attack string will enter into the vulnerable function. This will cause the attack string to fail. Likewise, the linefeed character will cause the parsing units of the string manipulation functions to interpret the linefeed as a user hitting the enter key. This will again cause premature failure of the attack string.</p>
<p>Let us try a simple example, such as:</p>
<p><img alt="" src="../../../_images/example_piping_into_xxd.jpg" /></p>
<p>Example of piping data into xxd to observe the hexadecimal values of the characters</p>
<p>In the above screenshot, we use the echo command to take the entire output of the commands within the “$()” and echo it to the screen. However, since we are using the unix pipe, the output is instead piped to the xxd command, which displays the hexadecimal values of the characters. Notice that there is a problem right at the end. There is a 0x0a character, which is the linefeed that the echo command affixes to the end. To suppress this trailing linefeed, the -n switch is used with the echo command. In the second issuance of the echo command, the trailing linefeed is suppressed, and we get a nice collection of hexadecimal values to fill 64 spots.</p>
<p>We can now move forward with constructing the attack string.</p>
</section>
<hr class="docutils" />
<section id="putting-it-all-together">
<h3>Putting it all together<a class="headerlink" href="#putting-it-all-together" title="Permalink to this heading">#</a></h3>
<p>Recall that the attack string was:</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\( sudo ./meet mr &quot;\)</span>(perl -e ‘print “\x90”x200’; cat sc; perl -e ‘print “\x90”x27’ ;perl -e ‘print “\x18\xf2\xff\xbf”x38’)”</p>
</div></blockquote>
<p>We will focus on everything contained within the “$()” by piping it into xxd and seeing what we are actually putting into the vulnerable buffer.</p>
<p><img alt="" src="../../../_images/piping_attack_string_into_xxd.jpg" /></p>
<p>Piping the attack string into xxd</p>
<p>From the above screenshot, we can see that the attack string contains a prologue of 0x90 characters. The 0x90 is the hexadecimal value of the opcode for No OPeration, or the NOP. Since the CPU can not distingush data from executable code, the CPU begins executing the <strong><em>data</em> as if it were <em>code</em></strong>. This prologue of NOP instructions is called a NOP sled. The NOP sled is used to make it easier by relieving the requirement to be absolutely exact with the return address at the end of the attack string. The CPU’s instruction pointer needs to be made to fall anywhere within this NOP sled, so that it will begin sliding down the NOP sled and eventually hit the shellcode. We have highlighted the shellcode for clarity. The shellcode was developed within another section of this website and can be found here:</p>
<p><span class="xref myst">Shellcode Generation</span></p>
<p>How can we make the CPU’s instruction pointer point to somewhere in the NOP sled? This is where real hacking skill comes in. After the NOP sled and shellcode, we need to overflow the rest of the buffer with the memory address <em>of the buffer</em>.</p>
<p>From where do we get this address? In our case, we have access to the source code and debugging information. Without the source code and debugging information, we would need to engage in reverse engineering of the executable. This is not impossible, but obviously much harder to do. For our purposes here, we will work on the easier case of knowing the exact memory address of the buffer we wish to overflow.</p>
<p>In our easier case, there are two ways of finding out the memory address of the buffer we wish to overflow.</p>
<ul class="simple">
<li><p>Modifiying the source code to print out the memory address of the buffer.</p></li>
<li><p>Using the debugger GDB to find out the memory address of the buffer.</p></li>
</ul>
<p>This may seem to easy to many of you, and indeed it is. So we will also explore trying to overflow the buffer when knowing only the location of the stack pointer.</p>
</section>
<hr class="docutils" />
<section id="discovering-the-memory-address-of-the-buffer-we-wish-to-overflow">
<h3>Discovering the memory address of the buffer we wish to overflow<a class="headerlink" href="#discovering-the-memory-address-of-the-buffer-we-wish-to-overflow" title="Permalink to this heading">#</a></h3>
<p>We now explore how to discover the memory address of the buffer we wish to overflow. Recall that when running the vulnerable executable <em>meet</em> with normal inputs, we obtain the following output:</p>
<p><img alt="" src="../../../_images/running_meet_normally.jpg" /></p>
<p>Discovering the memory address of the buffer we want to overflow. The buffer is called “name”.</p>
<p>We can see from the above screenshot that the memory address of the buffer that we want to overflow is:</p>
<blockquote>
<div><p>The address of the name array is: 0xbfffee28</p>
</div></blockquote>
<p>The memory address 0xbfffee28 is what we need to append to the end of the shellcode enough times so that this address will overwrite the saved EIP. By doing so, when the CPU reaches the <em>ret</em> assembly instruction as it leaves the called function <em>greeting</em>, it will load the instruction pointer with the memory address 0xbfffee28, and then begin execution of the instructions there. Those instructions are the NOP sled, followed by our shellcode!</p>
<p>Of course, it is not always that simple. This address needs to be four byte aligned and input into the attack string in reverse order, since memory in IA32 is written in Little-Endian format. So in the case of 0xbfffee28, we would write it as \x28\xee\xff\xbf. In order to align the address to 4 bytes, we will need to add some NOP instruction padding so that the address 0xbfffee28 does not sit in the next byte location in memory after the shellcode, but rather in a fresh new 32 bit (4 byte) location. Otherwise, this address will be a shifted version of itself when the CPU tries to read it off of the stack. In that case, the address may be read as 0xee28bfff or 0xffee28bf. I both of those cases, the program will most certainly crash with an out of bounds or illegal instruction segmentation fault.</p>
<p>Note that this address may change slightly with each execution of the program <em>meet</em>; therefore, some persistance is necessary when attacking from the command line. We will now explore using the debugger GDB for finding out the address of the buffer we want to overflow. Refer to the screenshot below:</p>
<p><img alt="" src="../../../_images/finding_the_mem_address_of_name_GEF.jpg" /></p>
<p>Discovering the memory address of the buffer we want to overflow. The buffer is called “name”.</p>
<p>We can see from the GEF User Interface (UI) to GDB that we are at the vulnerable <em>strcpy</em> function:</p>
<blockquote>
<div><p>strcpy (name, temp2); // copy the function argumemt to name</p>
</div></blockquote>
<p>By the C calling convention, arguments passed to a function are pushed onto the stack in reverse order. We can see from the screenshot that <em>temp1</em> is at ESP+8, ESP+4 contains the memory address of <em>temp2</em> and at ESP we have the memory address of the local variable <em>name</em>. In this case, the memory address is 0xbfffea58. Note that we are looking for the memory address of the local variable <em>name</em>, NOT what the register ESP (stack pointer) points to, but rather what is at the memory address that the ESP points to. In other words, ESP points to an address on the stack, 0xbfffea50, and at this memory address, there is stored another memory address which is 0xbfffea58. The contents of the memory location at the address 0xbfffea58 is the value 6, which is really just a random value, since the local variable <em>name</em> is uninitialized.</p>
<p>To confirm these statements, we observe the stack after the strcpy function returns.</p>
<p><img alt="" src="../../../_images/state_of_CPU_and_mem_after_strcpy_GEF.jpg" /></p>
<p>State of CPU registers, stack and relevant memory addresses after the strcpy command.</p>
<p>We can see from the above screen shot that the passed argument <em>temp2</em>, at stack memory location 0xbfffea54, has been copied to stack location 0xbfffea50. These correspond to ESP + 4 and ESP respectively.</p>
<p>We also observe that the function strcpy returns a pointer to a character (i.e. a string), and by convention, this pointer is returned into the register EAX. From the Linux man page for strcpy:</p>
<blockquote>
<div><p>char *strcpy(char *dest, const char *src);</p>
</div></blockquote>
<p>We can observe from the above screenshot that the returned value into EAX is: 0xbfffea58, which is the memory address of the local variable <em>name</em> on the stack. This is the memory address of the buffer we need to overflow.</p>
</section>
<section id="calculating-how-many-bytes-we-need-to-inject-into-the-vulnerable-buffer-to-overwrite-the-instruction-pointer-eip">
<h3>Calculating how many bytes we need to inject into the vulnerable buffer to overwrite the instruction pointer EIP.<a class="headerlink" href="#calculating-how-many-bytes-we-need-to-inject-into-the-vulnerable-buffer-to-overwrite-the-instruction-pointer-eip" title="Permalink to this heading">#</a></h3>
<p>So how many attack string bytes do we need to put onto the stack? We will need to fill up 400 bytes of the buffer called <em>name</em>. This is the local variable in the function greeting. Then we need 400 bytes for the argument passed to the function greeting called <em>temp2</em>, 4 bytes for the argument passed to the function greeting called <em>temp1</em>. Finally we need 4 bytes for the saved EBP. That is a total of 808 bytes. The next 4 bytes that we must overwrite is the <strong>saved instruction pointer EIP</strong>.</p>
<p>See the below screenshots for the state of execution just before the saved EIP is popped off of the stack, and execution is supposed to return back to the main function in the executable <em>meet</em>. Execution never returns to the main function, but instead the shellcode is executed.</p>
</section>
<section id="state-of-execution-just-before-the-saved-eip-is-popped-off-of-the-stack-and-execution-is-supposed-to-return-back-to-the-main-function-in-the-executable-meet-according-to-the-gef-ui-for-gdb">
<h3>State of execution just before the saved EIP is popped off of the stack, and execution is supposed to return back to the main function in the executable <em>meet</em>, according to the GEF UI for GDB.<a class="headerlink" href="#state-of-execution-just-before-the-saved-eip-is-popped-off-of-the-stack-and-execution-is-supposed-to-return-back-to-the-main-function-in-the-executable-meet-according-to-the-gef-ui-for-gdb" title="Permalink to this heading">#</a></h3>
<p><img alt="" src="../../../_images/just_before_attacked_ret_popped_from_stack_GEF.jpg" /></p>
<p>Stack just before return to main as per GEF.</p>
<p><img alt="" src="../../../_images/just_before_attacked_ret_popped_from_stack_PEDA.jpg" /></p>
<p>Stack just before return to main as per PEDA</p>
<p>We can see from the above screenshots, for both the PEDA GDB UI and the GEF GDB UI, that the memory address of the <em>name</em> local variable is: 0xbfffef3a. However, the address of the top of the stack is different. For GEF it is 0xbfffebec, and for PEDA it is 0xbfffec0c. This discrepancy was caused by the executable <em>meet</em> being started as two different processes, each with its own address space. One process was started for GEF, and another one for PEDA.</p>
<p>Therefore we should not be surprised that the top of the stack is different on each invocation of an executable, even with address randomization turned on. To make the calculation, we simply subtract the address of the top of the stack from the address of the buffer. In both cases, we obtain the following calculations:</p>
<p>GDB UI Name</p>
<p>Memory Address of Buffer</p>
<p>Memory Address of Top of Stack</p>
<p>Difference in Hex [bytes]</p>
<p>Difference in Decimal [bytes]</p>
<p>GEF</p>
<p>0xbfffef3a</p>
<p>0xbfffebec</p>
<p>0x34e</p>
<p>846</p>
<p>PEDA</p>
<p>0xbfffef3a</p>
<p>0xbfffec0c</p>
<p>0x32e</p>
<p>814</p>
<p>Stated mathematically, we have:</p>
<blockquote>
<div><p>GEF 0xbfffef3a - 0xbfffebec = 0x34e bytes = 846 bytes</p>
<p>PEDA 0xbfffef3a - 0xbfffec0c = 0x32e bytes = 814 bytes</p>
</div></blockquote>
<p>The astute reader will notice that we calculated the theoretical number of bytes needed to overwrite the saved EIP was 812 bytes. However, in both cases, GEF and PEDA, we have more than 812 bytes. The reason is that we are allowed to overwrite even through the top of the stack, as long as the saved EIP is overwritten with the address of the overflowed buffer, and this address is aligned correctly to 4 bytes. If it is misaligned, then instead of reading 0xbfffef3a from the top of the stack, the CPU might read a shifted version of this. If this happens, the CPU will jump to this shifted version of the address that we want, and will most likely halt on a segmentation fault.</p>
<p>In order to verify that the attack string arranges its return addresses correctly aligned to 4 bytes, we could do a number of things. Within GDB, we could simply issue the following command:</p>
<p><img alt="" src="../../../_images/examining_812_bytes_below_ESP.jpg" /></p>
<p>Examining stack memory 812 bytes below ESP</p>
<p>Referring to the screenshot above, we wanted to observe the contents of stack memory starting at ESP and going down by 812 bytes. Notice that since the stack grows downward, we need to do the opposite operation, and <em>add</em> 812 bytes, rather than subtract. To look at a byte, we need two hexadecimal digits; therefore, looking at 300 hexadecimal digits will show us 900 bytes. This will enable us to see our entire attack string in stack memory, with some margin. To accomplish this, we enter the following command:</p>
<blockquote>
<div><p>(gdb) x/300x $esp+812</p>
</div></blockquote>
<p>Notice from the above screenshot that there is a NULL byte just ahead of our NOP sled. Since we are aiming for the middle of the NOP sled, this leading NULL bytes is of little consquence. Now that we have discovered the address of the vulnerable buffer, and figured out how many bytes we need to inject into it for a successful buffer overflow, we will now look at how to discover the stack address from the command line.</p>
</section>
</section>
<section id="discovering-the-memory-address-of-the-stack">
<h2>Discovering the memory address of the stack<a class="headerlink" href="#discovering-the-memory-address-of-the-stack" title="Permalink to this heading">#</a></h2>
<section id="variations-in-the-top-of-the-stack-with-multiple-attack-attempts-from-the-command-line">
<h3>Variations in the top of the stack with multiple attack attempts from the command line<a class="headerlink" href="#variations-in-the-top-of-the-stack-with-multiple-attack-attempts-from-the-command-line" title="Permalink to this heading">#</a></h3>
<p>Before we can figure out the return address to place onto the stack so that we can successfuly overwrite the saved EIP, we need to know the current address of the stack. This is a little bit tricky, because every time the attack is attempted, the stack address changes a little bit, even with ASLR turned off. The reason is that Linux tries to reclaim memory after the failed attack completes, and other processes are always executing at the same time, so the stack address tends to shift around a bit, by about 500 to 1000 bytes.</p>
<p>While this is not a large range, it is enough to render the attack string useless, as it will probably crash with a segmentation fault, or the attack will simply be ignored. This all depends on which way the top of the stack has shifted in memory. However, command line attacks are still possible as the stack will most likely stay at the same location for a few attempted attacks.</p>
<p>In the next section, we will demonstrate a small C program that can print out the current memory address of the stack.</p>
</section>
</section>
<section id="id1">
<h2>Discovering the memory address of the stack<a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h2>
<section id="a-small-program-that-displays-the-current-state-of-the-stack-pointer">
<h3>A small program that displays the current state of the stack pointer<a class="headerlink" href="#a-small-program-that-displays-the-current-state-of-the-stack-pointer" title="Permalink to this heading">#</a></h3>
<p>To discover the address of the stack segment in memory, we use the program listed below</p>
<p>The program uses inline assembly within C. By convention, a the return value of a C function returns is contained within EAX. By calling the function get_sp, the ESP register is copied to EAX and returned to the printf statement. In this way, we obtain what is contained within ESP, the top of the stack.</p>
<p>This returned value is printed out as a memory address via the 0x%x format string. The screenshot below will display the output of running this program a few times.</p>
<p><img alt="" src="../../../_images/running_get_sp_many_times.jpg" /></p>
<p>Running get_sp many times to obtain the same memory address of the stack</p>
<p>Now that we have the address of the stack, or ESP, we can now make the calculation to figure out the return address that we want to append to the end of our attack string. We use our trusty HP48G calculator emulator for this purpose.</p>
<p><img alt="" src="../../../_images/calculating_return_address_w_dec_bytes_before.jpg" /></p>
<p>(A)</p>
<p><img alt="" src="../../../_images/calculating_return_address_w_hex_bytes_before.jpg" /></p>
<p>(B)</p>
<p><img alt="" src="../../../_images/calculating_return_address_w_hex_bytes_after_minus.jpg" /></p>
<p>(C)</p>
<p>Referring to the above calculator images: in (A) we have the address of the stack, 0xbfffee98 and 812 bytes that we will subtract; in (B) we have the same as in (A), but the 812 in decimal was converted to hex for clarity; and in (C) we have the result of the subtraction.</p>
</section>
<section id="lorem">
<h3>Lorem<a class="headerlink" href="#lorem" title="Permalink to this heading">#</a></h3>
<section id="id2">
<h4>Lorem<a class="headerlink" href="#id2" title="Permalink to this heading">#</a></h4>
<p>Lorem</p>
<p>Lorem</p>
</section>
<section id="id3">
<h4>Lorem<a class="headerlink" href="#id3" title="Permalink to this heading">#</a></h4>
<p><img alt="" src="../../../_images/images" /></p>
<p>Lorem</p>
<p>Lorem</p>
</section>
<section id="id4">
<h4>Lorem<a class="headerlink" href="#id4" title="Permalink to this heading">#</a></h4>
<p><img alt="" src="../../../_images/images" /></p>
<p>Lorem</p>
<p>Lorem</p>
<p><img alt="" src="../../../_images/images" /></p>
<p>Lorem</p>
<p>Lorem</p>
<p><img alt="" src="../../../_images/images" /></p>
<p>Lorem</p>
</section>
</section>
<section id="id5">
<h3>Lorem<a class="headerlink" href="#id5" title="Permalink to this heading">#</a></h3>
<section id="id6">
<h4>Lorem<a class="headerlink" href="#id6" title="Permalink to this heading">#</a></h4>
<p>Lorem</p>
</section>
<section id="id7">
<h4>Lorem<a class="headerlink" href="#id7" title="Permalink to this heading">#</a></h4>
<p><img alt="" src="../../../_images/images" /></p>
<p>Lorem</p>
<p>Lorem</p>
</section>
<section id="id8">
<h4>Lorem<a class="headerlink" href="#id8" title="Permalink to this heading">#</a></h4>
<p><img alt="" src="../../../_images/images" /></p>
<p>Lorem</p>
<p>Lorem</p>
</section>
<section id="id9">
<h4>Lorem<a class="headerlink" href="#id9" title="Permalink to this heading">#</a></h4>
<p><img alt="" src="../../../_images/images" /></p>
<p>Lorem</p>
<p>Lorem</p>
<p><img alt="" src="../../../_images/images" /></p>
<p>Lorem</p>
<p>Lorem</p>
<p><img alt="" src="../../../_images/images" /></p>
<p>Lorem</p>
<p>Lorem</p>
</section>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./Sections/Cybersecurity/Basic_Linux_Exploits"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="../LiveOverflow/liveoverflow.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">LiveOverflow</p>
      </div>
    </a>
    <a class="right-next"
       href="../../../markdown-notebooks.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Notebooks with MyST Markdown</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#computer-security-basic-linux-exploits">Computer Security - Basic Linux Exploits</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">Introduction</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction-to-buffer-overflows-and-preparing-a-32-bit-ubuntu-virtual-machine">Introduction to Buffer Overflows and Preparing a 32-bit Ubuntu Virtual Machine</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#brief-synopsis-of-meet-c">Brief synopsis of meet.c</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#disabling-address-space-layout-randomization-aslr">Disabling Address Space Layout Randomization (ASLR)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#smashing-the-stack-of-a-vulnerable-program-and-causing-a-buffer-overflow-overflowing-the-buffer-of-the-vulnerable-program-meet-c">Smashing the Stack of a Vulnerable Program and Causing a Buffer Overflow - Overflowing the Buffer of the Vulnerable Program meet.c</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compiling-meet-c-with-nx-disabled-with-debugging-information-and-static-compilation">Compiling meet.c with NX disabled, with debugging information and static compilation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#running-the-executable-meet-normally">Running the executable <em>meet</em> normally</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fuzzing-the-inputs-to-the-executable-meet">Fuzzing the inputs to the executable <em>meet</em></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#inserting-shellcode-into-a-vulnerable-processs-from-the-command-line-to-obtain-a-command-shell">Inserting Shellcode into a Vulnerable Processs from the Command Line to Obtain a Command Shell</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#breaking-down-the-attack-string-in-detail">Breaking Down the Attack String in Detail</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#use-of-the-cmd-cmd-cmd-cmd-format">Use of the “$(<em>cmd</em>; <em>cmd</em>; <em>cmd</em>; <em>cmd</em>)” format</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#using-to-craft-an-attack-string">Using “$()” to craft an attack string</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#putting-it-all-together">Putting it all together</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#discovering-the-memory-address-of-the-buffer-we-wish-to-overflow">Discovering the memory address of the buffer we wish to overflow</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#calculating-how-many-bytes-we-need-to-inject-into-the-vulnerable-buffer-to-overwrite-the-instruction-pointer-eip">Calculating how many bytes we need to inject into the vulnerable buffer to overwrite the instruction pointer EIP.</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#state-of-execution-just-before-the-saved-eip-is-popped-off-of-the-stack-and-execution-is-supposed-to-return-back-to-the-main-function-in-the-executable-meet-according-to-the-gef-ui-for-gdb">State of execution just before the saved EIP is popped off of the stack, and execution is supposed to return back to the main function in the executable <em>meet</em>, according to the GEF UI for GDB.</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#discovering-the-memory-address-of-the-stack">Discovering the memory address of the stack</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#variations-in-the-top-of-the-stack-with-multiple-attack-attempts-from-the-command-line">Variations in the top of the stack with multiple attack attempts from the command line</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Discovering the memory address of the stack</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-small-program-that-displays-the-current-state-of-the-stack-pointer">A small program that displays the current state of the stack pointer</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lorem">Lorem</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">Lorem</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">Lorem</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">Lorem</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">Lorem</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">Lorem</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">Lorem</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">Lorem</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">Lorem</a></li>
</ul>
</li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Mark Khusid
</p>

  </div>
  
  <div class="footer-item">
    

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=5b4479735964841361fd"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=5b4479735964841361fd"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>