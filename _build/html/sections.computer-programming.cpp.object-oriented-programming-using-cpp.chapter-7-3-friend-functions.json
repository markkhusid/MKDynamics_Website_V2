{"version":3,"kind":"Notebook","sha256":"79c8d23f7d8c7ca68cbb625c476d90cc00a2d2ce5cbfebe8eb5a573c2a677876","slug":"sections.computer-programming.cpp.object-oriented-programming-using-cpp.chapter-7-3-friend-functions","location":"/Sections/Computer_Programming/CPP/Object_Oriented_Programming_Using_Cpp/Chapter_7_3_Friend_Functions.ipynb","dependencies":[],"frontmatter":{"title":"Chapter 7.3: Friend Functions","content_includes_title":true,"kernelspec":{"name":"python3","display_name":"Python 3 (ipykernel)","language":"python"},"authors":[{"nameParsed":{"literal":"Mark Khusid","given":"Mark","family":"Khusid"},"name":"Mark Khusid","id":"contributors-myst-generated-uid-0"}],"github":"https://github.com/markkhusid/MKDynamics_Website_V2","numbering":{"title":{"offset":5}},"source_url":"https://github.com/markkhusid/MKDynamics_Website_V2/blob/master/Sections/Computer_Programming/CPP/Object_Oriented_Programming_Using_Cpp/Chapter_7_3_Friend_Functions.ipynb","edit_url":"https://github.com/markkhusid/MKDynamics_Website_V2/edit/master/Sections/Computer_Programming/CPP/Object_Oriented_Programming_Using_Cpp/Chapter_7_3_Friend_Functions.ipynb","exports":[{"format":"ipynb","filename":"Chapter_7_3_Friend_Functions.ipynb","url":"/build/Chapter_7_3_Friend_F-fd81fbc037cd8b8c82ef57b307ebef2b.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-content","children":[{"type":"code","lang":"","value":"---\njupytext:\n  formats: md:myst\n  text_representation:\n    extension: .md\n    format_name: myst\nkernelspec:\n  display_name: Python 3\n  language: python\n  name: python3\n---","key":"OsvE2fSAJz"}],"key":"ePMXXt0WSx"},{"type":"block","kind":"notebook-content","data":{"tags":[]},"children":[{"type":"heading","depth":1,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Chapter 7.3: Friend Functions","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"dFRQY4WhQr"}],"identifier":"chapter-7-3-friend-functions","label":"Chapter 7.3: Friend Functions","html_id":"chapter-7-3-friend-functions","implicit":true,"key":"AUiQRo20yT"}],"visibility":"show","key":"etZwUfZymi"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Adapted from: “Object-Oriented Programming Using C++” by Ira Pohl (Addison - Wesley)","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"DIzc34sdg0"}],"key":"sODUgRFTLK"}],"key":"iVO3qfF4ew"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Program that demonstrates friend functions selection in C++","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"LWyPzy2WgR"}],"identifier":"program-that-demonstrates-friend-functions-selection-in-c","label":"Program that demonstrates friend functions selection in C++","html_id":"program-that-demonstrates-friend-functions-selection-in-c","implicit":true,"key":"T5C4ogq8mm"}],"key":"SSlZVlvGTt"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"In file vect2.h","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"PwfXiUEDsv"}],"key":"KTC33LZcCq"}],"key":"r7723OUVBx"},{"type":"block","kind":"notebook-content","children":[{"type":"code","lang":"c++","value":"/*********************************************************************\n\n  Filename:  vect2.h\n  Chapter:   7      Ad Hoc Polymorphism\n  Section:   7.7    Friend Functions\n  Compiler:  Borland C++     Version 5.0       Summer 1996\n  Object Oriented Programming Using C++, Edition 2   By Ira Pohl\n\n*********************************************************************/\n\nclass matrix;                 // forward reference\n\n#include  <iostream>         // Changed iostream.h to iostream. MK.\n#include  <assert.h>\n\nusing namespace std;          // Added. MK.\n\nclass vect {\npublic:\n   vect() { size = 10; p = new int[size]; }\n   explicit vect(int n);\n   vect(const vect& v);\n   vect(const int a[], int n);  //initialize by array\n   ~vect() { delete []p; }\n   int  ub() const { return (size - 1); }  //upper bound\n   vect& operator=(const vect& v);  //overload assignment\n   void print() const;\n   int&  operator[](int i) ;         //range checked\n   vect operator+(const vect& v);\nprivate:\n   int*  p;\n   int   size;\n   friend vect mpy(const vect& v, const matrix& m);\n};\n\nvect::vect(int n) : size(n)\n{\n   assert(n > 0);\n   p = new int[size];\n   assert(p != 0);\n}\n\nvect::vect(const int a[], int n) : size(n)\n{\n   assert(n > 0);\n   p = new int[size];\n   assert(p != 0);\n   for (int i = 0; i < size; ++i)\n      p[i] = a[i];\n}\n\nvect::vect(const vect& v) : size(v.size)\n{\n   p = new int[size];\n   assert(p != 0);\n   for (int i = 0; i < size; ++i)\n      p[i] = v.p[i];\n}\n\nint& vect::operator[](int i)\n{\n   assert(i >= 0 && i < size);\n   return p[i];\n}\n\nvect& vect::operator=(const vect& v)\n{\n   int s = (size < v.size) ? size : v.size;\n\n   if (v.size != size)\n      cerr << \"copying different size arrays \"\n           << size << \" and \" << v.size << endl;\n   for (int i = 0; i < s; ++i)\n      p[i] = v.p[i];\n   return (*this);\n}\n\n\nvoid vect::print() const\n{\n   for (int i = 0; i <= (size-1); ++i)\n      cout << p[i] << \"\\t\";\n   cout << endl;\n}\n\nvect vect::operator+(const vect& v)\n{\n   assert(size == v.size);\n   vect  sum(size);\n   for (int i = 0; i < size; ++i)\n      sum.p[i] = p[i] + v.p[i];\n   return sum;\n}","position":{"start":{"line":1,"column":1},"end":{"line":95,"column":1}},"key":"YPXcIbmum5"}],"key":"GvbNp4tc31"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"In file matrix2.cpp","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"ehhDi4O8k6"}],"key":"fBx2xc8VbY"}],"key":"vvotC3agMW"},{"type":"block","kind":"notebook-content","children":[{"type":"code","lang":"c++","value":"/*********************************************************************\n\n  Filename:  matrix2.cpp\n  Chapter:   7      Ad Hoc Polymorphism\n  Section:   7.3    Friend Functions\n  Compiler:  Borland C++     Version 5.0       Summer 1996\n  Object Oriented Programming Using C++, Edition 2   By Ira Pohl\n\n*********************************************************************/\n\nclass matrix;                 // forward reference\n\n#include  <iostream>        // Changed iostream.h to iostream. MK.\n#include  <assert.h>\n#include  \"vect2.h\"\n\nusing namespace std;          // Added. MK.\n\nclass matrix {\npublic:\n   matrix(int d1, int d2);\n   ~matrix();\n   int  ub1() const { return(s1 - 1); }\n   int  ub2() const { return(s2 - 1); }\n   void print() const;\n   int&  element(int i, int j);\nprivate:\n   int**  p;\n   int    s1, s2;\n   friend    vect mpy(const vect& v, const matrix& m);\n};\n\nmatrix::matrix(int d1, int d2) : s1(d1), s2(d2)\n{\n   assert (d1 > 0 && d2 > 0);\n   p = new int*[s1];\n   assert(p != 0);\n   for (int i = 0; i < s1; ++i)\n      p[i] = new int[s2];\n}\n\nmatrix::~matrix()\n{\n   for (int i = 0; i <= ub1(); ++i)\n      delete p[i];\n   delete []p;\n}\n\nint& matrix::element(int i, int j)\n{\n   assert(i >= 0 || i <= ub1() || j >= 0 || j <= ub2());\n   return p[i][j];\n}\n\n\nvect mpy(const vect& v, const matrix& m)\n{\n   assert(v.size == m.s1);    //check sizes\n   //use privileged access to p in both classes\n   vect  ans(m.s2);\n   int   i, j;\n\n   for (i = 0; i <= m.ub2(); ++i) {\n      ans.p[i] = 0;\n      for (j = 0; j <= m.ub1(); ++j)\n         ans.p[i] += v.p[j] * m.p[j][i];\n   }\n   return ans;\n}\n\nvoid matrix::print() const\n{\n   int j;\n   for (int i = 0; i <= ub1(); ++i) {\n      cout << \"\\nrow  \" << (i + 1) << endl;\n      for (j = 0; j <= ub2(); ++j)\n         cout << p[i][j] << \"\\t\";\n   }\n   cout << endl;\n}\n\n\nvoid init_vect(vect& v, int start, int incr)\n{\n   for (int i = 0; i <= v.ub(); ++i) {\n      v[i] = start;\n      start += incr;\n   }\n}\n\nint main()\n{\n   vect   a(3), b(3), c(6), d(6);\n   matrix m(3, 6) ;\n   int    i, j;\n\n   a[0] = 1 + (a[1] = 1 + ( a[2] = 1)) ;\n   init_vect(b, 1, 1);\n   init_vect(c, 10, 10);\n   init_vect(d, 100, 1);\n\n   cout << \"vector a is\\n\";\n   a.print();\n   cout << \"\\nvector b is\\n\";\n   b.print();\n   cout << \"\\nvector c is\\n\";\n   c.print();\n   cout << \"\\nvector d is\\n\";\n   d.print();\n\n   for (i = 0; i <= m.ub1(); ++i)\n      for (j = 0; j <= m.ub2(); ++j)\n         m.element(i, j) = i + j;\n\n   cout << \"\\nmatrix m is\\n\";\n   m.print();\n\n   c = mpy(a, m);\n   cout << \"\\nvector c product is\\n\";\n   c.print();\n}","position":{"start":{"line":1,"column":1},"end":{"line":123,"column":1}},"key":"rtSewak7PC"}],"key":"kKwG9FstTl"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Compilation Process","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"XLxr13DxXu"}],"identifier":"compilation-process","label":"Compilation Process","html_id":"compilation-process","implicit":true,"key":"xHDWJygpgs"}],"key":"a66Vztoecu"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"The above program is compiled and run using Gnu Compiler Collection (g++):","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"WsUCaw5Zcn"}],"key":"TkD0sb5RUL"}],"key":"KCt3wvECht"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import os\nroot_dir = os.getcwd()","key":"XkmKmUsIIE"},{"type":"outputs","id":"TNmBE__GXtJGY5m8yaWah","children":[],"key":"kyZhRIhAe1"}],"key":"TgLckDvQMk"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"code_dir = root_dir + \"/\" + \\\n    \"Cpp_Code/Chapter_7_3_Friend_Functions\"","key":"CMhiOcV4K0"},{"type":"outputs","id":"TXQXT3lGJC3NhTMCiSp5a","children":[],"key":"XuR35fyG9m"}],"key":"rZfdx6WQW4"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"os.chdir(code_dir)","key":"Pn9C0HP87I"},{"type":"outputs","id":"bqZiN5GnZconAE-qwgUtR","children":[],"key":"hxvqf0jior"}],"key":"XBo7GJsFJ9"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"build_command = os.system(\"g++ matrix2.cpp -w -o matrix2\")","key":"FwXkzbTacD"},{"type":"outputs","id":"gJddy-AkGf8pXeBAA5pLS","children":[],"key":"hAAOM8KHxa"}],"key":"fbWua9WIcH"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Execution Process","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"ZqCiIvolHT"}],"identifier":"execution-process","label":"Execution Process","html_id":"execution-process","implicit":true,"key":"Fk43cpzM57"}],"key":"Cl3jukbZqJ"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"exec_status = os.system(\"./matrix2\")","key":"Wbtj2Tt9bE"},{"type":"outputs","id":"AfePM8QWdax1WIBoWVDDw","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"vector a is\n3\t2\t1\t\n\nvector b is\n1\t2\t3\t\n\nvector c is\n10\t20\t30\t40\t50\t60\t\n\nvector d is\n100\t101\t102\t103\t104\t105\t\n\nmatrix m is\n\nrow  1\n0\t1\t2\t3\t4\t5\t\nrow  2\n1\t2\t3\t4\t5\t6\t\nrow  3\n2\t3\t4\t5\t6\t7\t\n\nvector c product is\n4\t10\t16\t22\t28\t34\t\n"},"children":[],"key":"ntt0LgHg7X"}],"key":"idppdhAnRD"}],"key":"rstt4ePTGN"}],"key":"gQw4kvDkLr"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Chapter 7.2: Overloading and Function Selection","url":"/sections/computer-programming/cpp/object-oriented-programming-using-cpp/chapter-7-2-overloading-and-function-selection","group":"Computer Programming"},"next":{"title":"Chapter 7.5/7.6: Unary/Binary Operator Overloading","url":"/sections/computer-programming/cpp/object-oriented-programming-using-cpp/chapter-7-6-binary-operator-overloading","group":"Computer Programming"}}},"domain":"http://localhost:3010"}