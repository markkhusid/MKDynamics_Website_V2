{"version":3,"kind":"Notebook","sha256":"908ffc0d346d5c10d9b5a4d79354e2194eca89a89e0365d9f2d6c85f8e1067c6","slug":"sections.mcs-portfolio-project.l3firewall","location":"/Sections/MCS_Portfolio_Project/L3Firewall.ipynb","dependencies":[],"frontmatter":{"title":"L3Firewall.py","content_includes_title":false,"authors":[{"nameParsed":{"literal":"Mark Khusid","given":"Mark","family":"Khusid"},"name":"Mark Khusid","id":"contributors-myst-generated-uid-0"}],"github":"https://github.com/markkhusid/MKDynamics_Website_V2","numbering":{"title":{"offset":2}},"source_url":"https://github.com/markkhusid/MKDynamics_Website_V2/blob/master/Sections/MCS_Portfolio_Project/L3Firewall.ipynb","edit_url":"https://github.com/markkhusid/MKDynamics_Website_V2/edit/master/Sections/MCS_Portfolio_Project/L3Firewall.ipynb","exports":[{"format":"ipynb","filename":"L3Firewall.ipynb","url":"/L3Firewall-52a30a27807ba460c5aa47b6bb49fcd6.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"from pox.core import core\nimport pox.openflow.libopenflow_01 as of\nfrom pox.lib.revent import *\nfrom pox.lib.util import dpidToStr\nfrom pox.lib.addresses import EthAddr\nfrom collections import namedtuple\nimport os\n''' New imports here ... '''\nimport csv\nimport argparse\nfrom pox.lib.packet.ethernet import ethernet, ETHER_BROADCAST\nfrom pox.lib.addresses import IPAddr\nimport pox.lib.packet as pkt\nfrom pox.lib.packet.arp import arp\nfrom pox.lib.packet.ipv4 import ipv4\nfrom pox.lib.packet.icmp import icmp\n\n# Import time to track duration of time that ddos flood is occuring for\nimport time\n\nlog = core.getLogger()\npriority = 60000\n\nl2config = \"l2firewall.config\"\nl3config = \"l3firewall.config\"\n\n# Track connections to detect ddos attack\nconnection_counter = {}\nBLOCK_THRESHOLD = 10 # connections\nBLOCK_TIME_WINDOW = 3 # seconds\n\n\nclass Firewall (EventMixin):\n\n\tdef __init__ (self,l2config,l3config):\n\t\tself.listenTo(core.openflow)\n\t\tself.disbaled_MAC_pair = [] # Store a tuple of MAC pair which will be installed into the flow table of each switch.\n\t\tself.fwconfig = list()\n\n\t\t'''\n\t\tRead the CSV file\n\t\t'''\n\t\tif l2config == \"\":\n\t\t\tl2config=\"l2firewall.config\"\n\t\t\t\n\t\tif l3config == \"\":\n\t\t\tl3config=\"l3firewall.config\" \n\t\twith open(l2config, 'rb') as rules:\n\t\t\tcsvreader = csv.DictReader(rules) # Map into a dictionary\n\t\t\tfor line in csvreader:\n\t\t\t\t# Read MAC address. Convert string to Ethernet address using the EthAddr() function.\n                                if line['mac_0'] != 'any':\n\t\t\t\t    mac_0 = EthAddr(line['mac_0'])\n                                else:\n                                    mac_0 = None\n\n                                if line['mac_1'] != 'any':\n        \t\t\t\tmac_1 = EthAddr(line['mac_1'])\n                                else:\n                                    mac_1 = None\n\t\t\t\t# Append to the array storing all MAC pair.\n\t\t\t\tself.disbaled_MAC_pair.append((mac_0,mac_1))\n\n\t\twith open(l3config) as csvfile:\n\t\t\tlog.debug(\"[*] Reading l3config file during initialization!\")\n\t\t\t#self.rules = csv.DictReader(csvfile)\n\t\t\tself.rules = [row for row in csv.DictReader(csvfile)]\n\t\t\tif not self.rules:\n\t\t\t\tlog.debug(\"[*] No rules found\")\n\t\t\tfor row in self.rules:\n\t\t\t\tlog.debug(\"[*] Saving individual rule parameters in rule dict !\")\n\t\t\t\ts_ip = row['src_ip']\n\t\t\t\td_ip = row['dst_ip']\n\t\t\t\ts_port = row['src_port']\n\t\t\t\td_port = row['dst_port']\n\t\t\t\tprint \"src_ip, dst_ip, src_port, dst_port\", s_ip,d_ip,s_port,d_port\n\t\t\tlog.debug(\"[*] Finished updating l3config file !\")\n\n\t\tlog.debug(\"[*] Enabling Firewall Module\")\n\n\tdef replyToARP(self, packet, match, event):\n\t\tlog.debug(\"[*] Entering replyToARP\")\n\t\tr = arp()\n\t\tr.opcode = arp.REPLY\n\t\tr.hwdst = match.dl_src\n\t\tr.protosrc = match.nw_dst\n\t\tr.protodst = match.nw_src\n\t\tr.hwsrc = match.dl_dst\n\t\te = ethernet(type=packet.ARP_TYPE, src = r.hwsrc, dst=r.hwdst)\n\t\te.set_payload(r)\n\t\tmsg = of.ofp_packet_out()\n\t\tmsg.data = e.pack()\n\t\tmsg.actions.append(of.ofp_action_output(port=of.OFPP_IN_PORT))\n\t\tmsg.in_port = event.port\n\t\tevent.connection.send(msg)\n\t\tlog.debug(\"[*] Exiting replyToARP\")\n\n\tdef allowOther(self,event):\n\t\tlog.debug(\"[*] Entered allowOther\")\n\t\tmsg = of.ofp_flow_mod()\n\t\tmatch = of.ofp_match()\n\t\taction = of.ofp_action_output(port = of.OFPP_NORMAL)\n\t\tmsg.actions.append(action)\n\t\tevent.connection.send(msg)\n\t\tlog.debug(\"[*] Exiting allowOther\")\n\n\tdef installFlow(self, event, offset, srcmac, dstmac, srcip, dstip, sport, dport, nwproto):\n\t\tlog.debug(\"[*] Entered installFlow\")\n\t\tmsg = of.ofp_flow_mod()\n\t\tmatch = of.ofp_match()\n\t\tif(srcip != None):\n\t\t\tmatch.nw_src = IPAddr(srcip)\n\t\tif(dstip != None):\n\t\t\tmatch.nw_dst = IPAddr(dstip)\t\n\t\tmatch.nw_proto = int(nwproto)\n\t\tmatch.dl_src = srcmac\n\t\tmatch.dl_dst = dstmac\n\t\tmatch.tp_src = sport\n\t\tmatch.tp_dst = dport\n\t\tmatch.dl_type = pkt.ethernet.IP_TYPE\n\t\tmsg.match = match\n\t\tmsg.hard_timeout = 0\n\t\tmsg.idle_timeout = 200\n\t\tmsg.priority = priority + offset\t\t\n\t\tevent.connection.send(msg)\n\t\tlog.debug(\"[*] Exiting installFlow\")\n\n\t# ************* My mods star here *******************\n\t# Create function to block offending MAC address\n\tdef blockMAC(self, event, mac_address):\n\t\t# Add a flow rule to block a MAC address permanently\n\t\tlog.debug(\"[*] Entered blockMAC\")\n\t\tmsg = of.ofp_flow_mod()\n\t\tmatch = of.ofp_match()\n\t\tmatch.dl_src = EthAddr(mac_address)\n\t\tmatch.dl_type = pkt.ethernet.IP_TYPE\n\t\tmsg.match = match\n\t\tmsg.priority = 65535 # high priority\n\t\tmsg.action = []\n\t\tevent.connection.send(msg)\n\t\tlog.debug(\"[*] Permanently blocked the MAC address %s\" % mac_address)\n\t\tlog.debug(\"[*] Exiting blockMAC\")\n\t# ************* My mods end here ********************\n\n\tdef replyToIP(self, packet, match, event, fwconfig):\n\t\tlog.debug(\"[*] Entered replyToIP\")\t\t\n\t\tsrcmac = str(match.dl_src)\n\t\tdstmac = str(match.dl_src)\n\t\tsport = str(match.tp_src)\n\t\tdport = str(match.tp_dst)\n\t\tnwproto = str(match.nw_proto)\n\n\t\t# ************* DDOS Mods start here *******************\n\t\tlog.debug(\"[*] Entered DDOS in replyToIP\")\n\t\tcurrent_time = time.time()\n\n\t\t# Create a new entry to track the new connection for possible offense\n\t\tif srcmac not in connection_counter:\n\t\t\tconnection_counter[srcmac] = []\n\t\tconnection_counter[srcmac].append(current_time)\n\n\t\t# Clean up connections that don't meet offensive threshold\t\t\n\t\tconnection_counter[srcmac] = \\\n\t\t\t[item for item in connection_counter[srcmac] if (current_time - item) <= BLOCK_TIME_WINDOW]\n\n\t\t# If the number of connections from the same MAC address exceeds the offense threshold, block.\n\t\tif len(connection_counter[srcmac]) > BLOCK_THRESHOLD:\n\t\t\tlog.debug(\"[*] Blocking MAC address %s for DDOS \" % srcmac)\n\t\t\tself.blockMAC(event, srcmac)\n\t\t\treturn\n\t\t# ************* DDOS Mods end here *******************\n\n\t\tlog.debug(\"[*] Processing rules in replyToIP\")\n\n\t\tif not self.rules:\n\t\t\tlog.debug(\"[*] Rules are empty\")\n\t\telse:\n\t\t\tlog.debug(\"[*] Rules are not empty\")\t\n\t\t\tfor row in self.rules:\n\t\t\t\tlog.debug(\"[**] in replyToIP for loop...\")\n\t\t\t\tprio = row['priority']\n\t\t\t\tsrcmac = row['src_mac']\n\t\t\t\tdstmac = row['dst_mac']\n\t\t\t\ts_ip = row['src_ip']\n\t\t\t\td_ip = row['dst_ip']\n\t\t\t\ts_port = row['src_port']\n\t\t\t\td_port = row['dst_port']\n\t\t\t\tnw_proto = row['nw_proto']\n\t\t\t\t\n\t\t\t\tlog.debug(\"[**] You are in original code block ...\")\n\t\t\t\tsrcmac1 = EthAddr(srcmac) if srcmac != 'any' else None\n\t\t\t\tdstmac1 = EthAddr(dstmac) if dstmac != 'any' else None\n\t\t\t\ts_ip1 = s_ip if s_ip != 'any' else None\n\t\t\t\td_ip1 = d_ip if d_ip != 'any' else None\n\t\t\t\ts_port1 = int(s_port) if s_port != 'any' else None\n\t\t\t\td_port1 = int(d_port) if d_port != 'any' else None\n\t\t\t\tprio1 = int(prio) if prio != None else priority\n\t\t\t\tif nw_proto == \"tcp\":\n\t\t\t\t\tnw_proto1 = pkt.ipv4.TCP_PROTOCOL\n\t\t\t\telif nw_proto == \"icmp\":\n\t\t\t\t\tnw_proto1 = pkt.ipv4.ICMP_PROTOCOL\n\t\t\t\t\ts_port1 = None\n\t\t\t\t\td_port1 = None\n\t\t\t\telif nw_proto == \"udp\":\n\t\t\t\t\tnw_proto1 = pkt.ipv4.UDP_PROTOCOL\n\t\t\t\telse:\n\t\t\t\t\tlog.debug(\"PROTOCOL field is mandatory, Choose between ICMP, TCP, UDP\")\n\t\t\t\tprint (prio1,s_ip1, d_ip1, s_port1, d_port1,nw_proto1)\n\t\t\t\tself.installFlow(event,prio1, srcmac1, dstmac1, s_ip1, d_ip1, s_port1, d_port1, nw_proto1)\n\t\t#log.debug(\"[*] Allowing other events\")\t\t\n\t\tself.allowOther(event)\n\t\tlog.debug(\"[*] Exiting replyToIP\")\n\n\n\tdef _handle_ConnectionUp (self, event):\n\t\tlog.debug(\"[*] Entered _handle_ConnectionUp\")\t\t\n\t\t''' Add your logic here ... '''\n\n\t\t'''\n\t\tIterate through the disbaled_MAC_pair array, and for each\n\t\tpair we install a rule in each OpenFlow switch\n\t\t'''\n\t\tself.connection = event.connection\n\n\t\tfor (source, destination) in self.disbaled_MAC_pair:\n\n\t\t\tprint source,destination\n\t\t\tmessage = of.ofp_flow_mod() # OpenFlow massage. Instructs a switch to install a flow\n\t\t\tmatch = of.ofp_match() # Create a match\n\t\t\tmatch.dl_src = source # Source address\n\n\t\t\tmatch.dl_dst = destination # Destination address\n\t\t\tmessage.priority = 65535 # Set priority (between 0 and 65535)\n\t\t\tmessage.match = match\t\t\t\n\t\t\tevent.connection.send(message) # Send instruction to the switch\n\n\t\tlog.debug(\"[*] Firewall rules installed on %s\", dpidToStr(event.dpid))\n\t\tlog.debug(\"[*] Exiting _handle_ConnectionUp\")\n\n\n\tdef _handle_PacketIn(self, event):\n\n\t\tlog.debug(\"[*] Entered _handle_PacketIn\")\n\t\tpacket = event.parsed\n\t\tmatch = of.ofp_match.from_packet(packet)\n\n\t\tif(match.dl_type == packet.ARP_TYPE and match.nw_proto == arp.REQUEST):\n\n\t\t  self.replyToARP(packet, match, event)\n\n\t\tif(match.dl_type == packet.IP_TYPE):\n\t\t  ip_packet = packet.payload\n\t\t  print \"Ip_packet.protocol = \", ip_packet.protocol\n\t\t  if ip_packet.protocol == ip_packet.TCP_PROTOCOL:\n\t\t\tlog.debug(\"[*] TCP it is !\")\n   \n\t\t  self.replyToIP(packet, match, event, self.rules)\n\t\t  self.allowOther(event)\n\t\tlog.debug(\"[*] Exiting _handle_PacketIn\")\n\n\ndef launch (l2config=\"l2firewall.config\",l3config=\"l3firewall.config\"):\n\t'''\n\tStarting the Firewall module\n\t'''\n\tparser = argparse.ArgumentParser()\n\tparser.add_argument('--l2config', action='store', dest='l2config',\n\t\t\t\t\thelp='Layer 2 config file', default='l2firewall.config')\n\tparser.add_argument('--l3config', action='store', dest='l3config',\n\t\t\t\t\thelp='Layer 3 config file', default='l3firewall.config')\n\tcore.registerNew(Firewall,l2config,l3config)","key":"gDXC8VuYJp"},{"type":"outputs","id":"Qx_LrQj5GTj3tYdi6LQ8p","children":[],"key":"EoJvO0szLq"}],"key":"knOD9jJYcR"}],"key":"yxOFcnBZx1"},"references":{"cite":{"order":[],"data":{}}}}