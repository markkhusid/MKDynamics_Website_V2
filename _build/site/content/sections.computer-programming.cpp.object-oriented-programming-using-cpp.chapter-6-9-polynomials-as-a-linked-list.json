{"version":3,"kind":"Notebook","sha256":"1b3aa726e4a34b1f71cbbd1a7fb27e0b7a119d999bd85555e69b127a1b61129a","slug":"sections.computer-programming.cpp.object-oriented-programming-using-cpp.chapter-6-9-polynomials-as-a-linked-list","location":"/Sections/Computer_Programming/CPP/Object_Oriented_Programming_Using_Cpp/Chapter_6_9_Polynomials_as_a_Linked_List.ipynb","dependencies":[],"frontmatter":{"title":"Chapter 6.9: Polynomials as a Linked List","content_includes_title":true,"kernelspec":{"name":"python3","display_name":"Python 3 (ipykernel)","language":"python"},"authors":[{"nameParsed":{"literal":"Mark Khusid","given":"Mark","family":"Khusid"},"name":"Mark Khusid","id":"contributors-myst-generated-uid-0"}],"github":"https://github.com/markkhusid/MKDynamics_Website_V2","numbering":{"title":{"offset":5}},"source_url":"https://github.com/markkhusid/MKDynamics_Website_V2/blob/master/Sections/Computer_Programming/CPP/Object_Oriented_Programming_Using_Cpp/Chapter_6_9_Polynomials_as_a_Linked_List.ipynb","edit_url":"https://github.com/markkhusid/MKDynamics_Website_V2/edit/master/Sections/Computer_Programming/CPP/Object_Oriented_Programming_Using_Cpp/Chapter_6_9_Polynomials_as_a_Linked_List.ipynb","exports":[{"format":"ipynb","filename":"Chapter_6_9_Polynomials_as_a_Linked_List.ipynb","url":"/Chapter_6_9_Polynomi-f6e0f28e2eba70662c0aaf0a2b616e4d.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-content","children":[{"type":"code","lang":"","value":"---\njupytext:\n  formats: md:myst\n  text_representation:\n    extension: .md\n    format_name: myst\nkernelspec:\n  display_name: Python 3\n  language: python\n  name: python3\n---","key":"h5XAWSIHmw"}],"key":"SMG76gvqWP"},{"type":"block","kind":"notebook-content","data":{"tags":[]},"children":[{"type":"heading","depth":1,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Chapter 6.9: Polynomials as a Linked List","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"g2wpD96PSw"}],"identifier":"chapter-6-9-polynomials-as-a-linked-list","label":"Chapter 6.9: Polynomials as a Linked List","html_id":"chapter-6-9-polynomials-as-a-linked-list","implicit":true,"key":"bQ6ArkEIqF"}],"visibility":"show","key":"VBNOqqX7xM"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Adapted from: “Object-Oriented Programming Using C++” by Ira Pohl (Addison - Wesley)","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"iovWLgY2Hb"}],"key":"rOjvkaQpmT"}],"key":"DciPZkAPtO"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Program that demonstrates using linked lists to store polynominals in C++","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"euAE6CymXQ"}],"identifier":"program-that-demonstrates-using-linked-lists-to-store-polynominals-in-c","label":"Program that demonstrates using linked lists to store polynominals in C++","html_id":"program-that-demonstrates-using-linked-lists-to-store-polynominals-in-c","implicit":true,"key":"NWfxacOrYo"}],"key":"L2e3Lyk9xv"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"In file poly1.cpp","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"o3sZcfl67x"}],"key":"sLEMboqAGi"}],"key":"aD0A9XXfpe"},{"type":"block","kind":"notebook-content","children":[{"type":"code","lang":"c++","value":"/*********************************************************************\n\n  Filename:  poly1.cpp\n  Chapter:   6      Object Creation and Destruction\n  Section:   6.9    Polynomial as a Linked List\n  Compiler:  Borland C++     Version 5.0       Summer 1996\n  Object Oriented Programming Using C++, Edition 2   By Ira Pohl\n\n*********************************************************************/\n\n//A polynomial represented as a singly linked list\n\n#include <assert.h>\n#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n\nusing namespace std;\n\n//A polynomial represented as a singly linked list\nstruct term {\n   int        exponent;\n   double     coefficient;\n   term*      next;\n   term(int e, double c, term* n = 0)\n       : exponent(e), coefficient(c), next(n) { }\n   void print()\n     {cout << coefficient << \"x^\" << exponent << \" \";}\n};\n\nclass polynomial {\npublic:\n   polynomial(): h(0), degree(0) { }\n   polynomial(const polynomial& p);\n   polynomial(int size, double coef[], int expon[]);\n   ~polynomial() { release(); }\n   void print() const;\n   void plus(polynomial a, polynomial b);\nprivate:\n   term*   h;\n   int     degree;\n   void    prepend(term*  t);   //add term to front\n   void    add_term(term*& a, term*& b);\n   void    release();           //garbage collect\n   void    rest_of(term* rest); //add remaining terms\n   void    reverse();           //reverse terms\n};\n\nvoid polynomial::reverse()       //in place\n{\n   term*  pred, *succ, *elem;\n\n   if (h && (succ = h -> next)) {\n      pred = 0;\n      elem = h;\n      while (succ) {\n         elem -> next = pred;\n         pred = elem;\n         elem = succ;\n         succ = succ -> next;\n      }\n      h = elem;\n      h -> next = pred;\n   }\n}\n\nvoid polynomial::release()\n{\n   term* temp = h;\n\n   if (h) {  h = h -> next; delete temp; release(); }\n\n\n}\n\ninline void polynomial::prepend(term*t)\n{\n    t -> next = h;\n     h = t;\n}\n\n\nvoid polynomial::print() const\n{\n   term* temp = h;\n\n   if (h == 0) { cout << \"0\\n\"; return; }\n   while (temp){ temp -> print(); temp = temp -> next; }\n   cout << endl;\n}\n//assumes ordering is correct expon[i] < expon[i+1]\npolynomial::polynomial(int size, double coef[],\n                       int expon[])\n{\n   term* temp = new term(expon[0], coef[0]);\n   assert(temp != 0);\n\n   h = 0;\n   prepend(temp);               //create initial term\n   for (int i = 1; i < size; ++i) {\n       assert(expon[i - 1] < expon[i]);\n       temp = new term(expon[i], coef[i]);\n       assert(temp != 0);\n       prepend(temp);          //add term\n   }\n   degree = h -> exponent;\n}\n\npolynomial::polynomial(const polynomial& p) :\n                       degree(p.degree)\n{\n   term* elem = p.h, *temp;\n\n   h = 0;\n   while (elem) {              //term by term copying\n      temp = new term(elem -> exponent,\n                      elem -> coefficient);\n      assert(temp != 0);\n      prepend(temp);\n      elem = elem -> next;\n   }\n   reverse();\n}\n\nvoid polynomial::add_term(term*& a, term*& b)\n{\n   term*  c;\n\n   if (a -> exponent > b -> exponent) { //add a\n      c = new term(a -> exponent, a -> coefficient) ;\n      assert(c != 0);\n      a = a -> next;\n      prepend(c);\n   }\n   else if (a -> exponent < b -> exponent){ //add b\n      c = new term(b -> exponent, b -> coefficient) ;\n      assert(c != 0);\n      b = b -> next;\n      prepend(c);\n   }\n    else { //check on cancellation\n       if (a -> coefficient + b -> coefficient != 0) {\n           c = new term( a -> exponent,\n                a -> coefficient + b -> coefficient);\n           assert(c != 0);\n           prepend(c);\n        }\n        a = a -> next;\n        b = b -> next;\n    }\n}\n\nvoid polynomial::rest_of(term* rest)\n{\n   term* temp;\n\n   while (rest) {\n      temp  = new term(rest -> exponent,\n                       rest -> coefficient);\n      assert(temp != 0);\n      prepend(temp);\n      rest = rest -> next;\n   }\n}\n\n//c.plus(a,b) means c = a + b;\nvoid polynomial::plus(polynomial a, polynomial b)\n{\n   term*    aterm = a.h, *bterm = b.h;\n\n   release();  //garbage collect c, assumes not a or b\n   h = 0;\n   while (aterm && bterm)     //merge step\n      add_term(aterm, bterm);\n   if (aterm)\n      rest_of(aterm);\n   else if (bterm)\n      rest_of(bterm);\n   reverse();\n   degree = ((h) ? h -> exponent: 0);\n}\n\ndouble coef[4] = {1, 2, 3, 4};\ndouble coef2[4] = {-1,-2, -3, -4};\nint    expo[4] = {0, 4, 14, 45};\n\nmain()\n{\n   polynomial p(4, coef2,expo), q(4,coef,expo), s;\n\n   cout << \"P(x) = \";\n   p.print();\n   cout << \"Q(x) = \";\n   q.print();\n   s.plus(q,q);\n   cout << \"S(x) = Q(x) + Q(x) = \";\n   s.print();\n   s.plus(p, q);\n   cout << \"S(x) = P(x) + Q(x) = \";\n   s.print();\n}","position":{"start":{"line":1,"column":1},"end":{"line":203,"column":1}},"key":"D0cWaeFcvi"}],"key":"s7o5MMTkiI"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Compilation Process","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"zQVZ6LuX1R"}],"identifier":"compilation-process","label":"Compilation Process","html_id":"compilation-process","implicit":true,"key":"P56Op1hNpe"}],"key":"XfJZXkRCm4"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"The above program is compiled and run using Gnu Compiler Collection (g++):","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"iFAP7M7D2v"}],"key":"XkjZUQJMWA"}],"key":"aNcqKfybIK"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import os\nroot_dir = os.getcwd()","key":"ijFjLJHJ8A"},{"type":"outputs","id":"hXM7uxdJvUBkQPx0LwA2k","children":[],"key":"nRPxUArikj"}],"key":"mCt2CYs0Cl"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"code_dir = root_dir + \"/\" + \\\n    \"Cpp_Code/Chapter_6_9_Polynomials_as_a_Linked_List\"","key":"Se9GUUeuCK"},{"type":"outputs","id":"AYsfwaewWObcWMFLVL3AJ","children":[],"key":"wrXHwRZ1Ie"}],"key":"LMXRhrT3JO"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"os.chdir(code_dir)","key":"aGbTjgMLvN"},{"type":"outputs","id":"9bzd_tqAQY4CTcj_JQmhB","children":[],"key":"s5naHDhMVS"}],"key":"RN0RLkfQZO"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"build_command = os.system(\"g++ poly1.cpp -w -o poly1\")","key":"I5mpzh0mMv"},{"type":"outputs","id":"39MshVjBNlkHxuEuC1L7y","children":[],"key":"EvAsS70rPG"}],"key":"Tsi4bNncdA"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Execution Process","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"p6P6UIPYPG"}],"identifier":"execution-process","label":"Execution Process","html_id":"execution-process","implicit":true,"key":"DnpAzupbp3"}],"key":"IDup2o5hwZ"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"exec_status = os.system(\"./poly1\")","key":"kQGCiT9isj"},{"type":"outputs","id":"vpT912x-2OrQRcxcXVuH7","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"P(x) = -4x^45 -3x^14 -2x^4 -1x^0 \nQ(x) = 4x^45 3x^14 2x^4 1x^0 \nS(x) = Q(x) + Q(x) = 8x^45 6x^14 4x^4 2x^0 \nS(x) = P(x) + Q(x) = 0\n"},"children":[],"key":"O0ndE5yTPD"}],"key":"KA9tmi4BXR"}],"key":"byczkjmeHF"}],"key":"Et7b41JjGp"},"references":{"cite":{"order":[],"data":{}}}}